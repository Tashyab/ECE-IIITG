C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE USBUART
OBJECT MODULE PLACED IN .\DP8051_Keil_951\Debug\USBUART.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\4.4\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -Generated_Source\PSoC3\USBUART.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB WL(2) PR(.\
                    -DP8051_Keil_951\Debug/USBUART.lst) CD OT(2,SIZE) OJ(.\DP8051_Keil_951\Debug\USBUART.obj)

line level    source

   1          /***************************************************************************//**
   2          * \file USBUART.c
   3          * \version 3.10
   4          *
   5          * \brief
   6          *  This file contains the global USBFS API functions.
   7          *
   8          * Note:
   9          *  Many of the functions use an endpoint number. SRAM arrays are sized with 9
  10          *  elements, so they are indexed directly by epNumber.  The SIE and ARB
  11          *  registers are indexed by variations of epNumber - 1.
  12          *
  13          ********************************************************************************
  14          * \copyright
  15          * Copyright 2008-2016, Cypress Semiconductor Corporation.  All rights reserved.
  16          * You may use this file only in accordance with the license, terms, conditions,
  17          * disclaimers, and limitations in the end user license agreement accompanying
  18          * the software package with which this file was provided.
  19          *******************************************************************************/
  20          
  21          #include "USBUART_pvt.h"
  22          #include "USBUART_cydmac.h"
  23          #include "USBUART_hid.h"
  24          #include "USBUART_Dp.h"
  25          
  26          
  27          /***************************************
  28          * Global data allocation
  29          ***************************************/
  30          
  31          /** Indicates whether the USBFS has been initialized. The variable is
  32          * initialized to 0 after device reset and set to 1 the first time USBFS_Start()
  33          * is called. This allows the Component to restart without reinitialization after
  34          * the first call to the USBFS_Start() routine.
  35          * If re-initialization of the Component is required, the variable should be set
  36          * to 0 before the USBFS_Start() routine is called. Alternatively, the USBFS can
  37          * be reinitialized by calling both USBFS_Init() and USBFS_InitComponent()
  38          * functions.
  39          */
  40          uint8 USBUART_initVar = 0u;
  41          
  42          #if (USBUART_EP_MANAGEMENT_DMA)
                  #if (CY_PSOC4)
                      static void USBUART_InitEpDma(void);
              
                      /* DMA chanels assigend for endpoints. */
                      const uint8 USBUART_DmaChan[USBUART_MAX_EP] =
                      {
                          0u,
                          0u,
                          0u,
                          0u,
                          0u,
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 2   

                          0u,
                          0u,
                          0u,
                          0u,
                      };        
                  #else
                      /* DMA chanels assigend for endpoints. */
                      uint8 USBUART_DmaChan[USBUART_MAX_EP];
                      
                      /* DMA TDs require for PSoC 3/5LP operation. */
                      uint8 USBUART_DmaTd[USBUART_MAX_EP];
                  #endif /* (CY_PSOC4) */
              #endif /* (USBUART_EP_MANAGEMENT_DMA) */
  67          
  68          #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
              #if (CY_PSOC4)
                  /* Number of DMA bursts. */
                  uint8  USBUART_DmaEpBurstCnt   [USBUART_MAX_EP];
                  
                  /* Number of bytes to transfer in last DMA burst. */
                  uint8  USBUART_DmaEpLastBurstEl[USBUART_MAX_EP];
              
                  /* Storage for arrays above. */
                  uint8  USBUART_DmaEpBurstCntBackup  [USBUART_MAX_EP];
                  uint32 USBUART_DmaEpBufferAddrBackup[USBUART_MAX_EP];
                   
                  /* DMA trigger mux output for usb.dma_req[0-7]. */
                  const uint8 USBUART_DmaReqOut[USBUART_MAX_EP] =
                  {
                      0u,
                      USBUART_ep1_dma__TR_OUTPUT,
                      USBUART_ep2_dma__TR_OUTPUT,
                      USBUART_ep3_dma__TR_OUTPUT,
                      0u,
                      0u,
                      0u,
                      0u,
                      0u,
                  };
              
                  /* DMA trigger mux output for usb.dma_burstend[0-7]. */
                  const uint8 USBUART_DmaBurstEndOut[USBUART_MAX_EP] =
                  {
                      0u,
                      USBUART_BURSTEND_0_TR_OUTPUT,
                      USBUART_BURSTEND_1_TR_OUTPUT,
                      USBUART_BURSTEND_2_TR_OUTPUT,
                      USBUART_BURSTEND_3_TR_OUTPUT,
                      USBUART_BURSTEND_4_TR_OUTPUT,
                      USBUART_BURSTEND_5_TR_OUTPUT,
                      USBUART_BURSTEND_6_TR_OUTPUT,
                      USBUART_BURSTEND_7_TR_OUTPUT
                  };
                  
              #else
                  #if (USBUART_EP_DMA_AUTO_OPT == 0u)
                      static uint8 clearInDataRdyStatus = USBUART_ARB_EPX_CFG_DEFAULT;
                      uint8 USBUART_DmaNextTd[USBUART_MAX_EP];
                      const uint8 USBUART_epX_TD_TERMOUT_EN[USBUART_MAX_EP] =
                      {
                          0u,
                          0u,
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 3   

                          0u,
                          0u,
                          0u,
                          0u,
                          0u,
                          0u,
                          0u,
                      };
              
                      volatile uint16 USBUART_inLength[USBUART_MAX_EP];
                      const uint8 *USBUART_inDataPointer[USBUART_MAX_EP];
                      volatile uint8 USBUART_inBufFull[USBUART_MAX_EP];
                  #endif /* (USBUART_EP_DMA_AUTO_OPT == 0u) */
              #endif /* (CY_PSOC4) */
              #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
 131          
 132          
 133          /*******************************************************************************
 134          * Function Name: USBUART_Start
 135          ****************************************************************************//**
 136          *
 137          *   This function performs all required initialization for the USBFS component.
 138          *   After this function call, the USB device initiates communication with the
 139          *   host by pull-up D+ line. This is the preferred method to begin component
 140          *   operation.
 141          *
 142          *   Note that global interrupts have to be enabled because interrupts are
 143          *   required for USBFS component operation.
 144          *
 145          *   PSoC 4200L devices: when USBFS component configured to DMA with Automatic
 146          *   Buffer Management, the DMA interrupt priority is changed to the highest
 147          *   (priority 0) inside this function.
 148          *
 149          *   PSoC 3/PSoC 5LP devices: when USBFS component configured to DMA with
 150          *   Automatic Buffer Management, the Arbiter interrupt priority is changed to
 151          *   the highest (priority 0) inside this function.
 152          *
 153          *  \param device
 154          *          Contains the device number of the desired device descriptor.
 155          *          The device number can be found in the Device Descriptor Tab of
 156          *          "Configure" dialog, under the settings of desired Device Descriptor,
 157          *          in the "Device Number" field.
 158          *  \param mode:
 159          *   The operating voltage. This determines whether the voltage regulator
 160          *   is enabled for 5V operation or if pass through mode is used for 3.3V
 161          *   operation. Symbolic names and their associated values are given in the
 162          *   following list.
 163          *
 164          *       *USBUART_3V_OPERATION* - Disable voltage regulator and pass-
 165          *                                      through Vcc for pull-up
 166          *
 167          *       *USBUART_5V_OPERATION* - Enable voltage regulator and use
 168          *                                      regulator for pull-up
 169          *
 170          *       *USBUART_DWR_POWER_OPERATION* - Enable or disable the voltage
 171          *                                      regulator depending on the power supply
 172          *                                      voltage configuration in the DWR tab.
 173          *                                      For PSoC 3/5LP devices, the VDDD supply
 174          *                                      voltage is considered and for PSoC 4A-L,
 175          *                                      the VBUS supply voltage is considered.*
 176          * \globalvars
 177          *  \ref USBUART_initVar
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 4   

 178          *
 179          * \sideeffect
 180          *   This function will reset all communication states to default.
 181          *
 182          * \reentrant
 183          *  No.
 184          *
 185          *******************************************************************************/
 186          void USBUART_Start(uint8 device, uint8 mode) 
 187          {
 188   1          if (0u == USBUART_initVar)
 189   1          {
 190   2              USBUART_Init();
 191   2              USBUART_initVar = 1u;
 192   2          }
 193   1      
 194   1          USBUART_InitComponent(device, mode);
 195   1      }
 196          
 197          
 198          /*******************************************************************************
 199          * Function Name: USBUART_Init
 200          ****************************************************************************//**
 201          *
 202          * This function initializes or restores the component according to the
 203          * customizer Configure dialog settings. It is not necessary to call
 204          * USBUART_Init() because the USBUART_Start() routine calls
 205          * this function and is the preferred method to begin component operation.
 206          *
 207          * \reentrant
 208          *  No.
 209          *
 210          *******************************************************************************/
 211          void USBUART_Init(void) 
 212          {
 213   1      #if (CY_PSOC4)
                  /* Enable clock to USB IP. */
                  USBUART_USB_CLK_EN_REG = USBUART_USB_CLK_CSR_CLK_EN;
              
                  /* The internal regulator (CR1.REG_ENABLE) is enabled in
                  * USBUART_InitComponent() if it is required.
                  */
              
                  /* Enable USBIO control on drive mode of D+ and D- pins. */
                  USBUART_USBIO_CR1_REG &= ~ (uint32) USBUART_USBIO_CR1_IOMODE;
              
                  /* Set number of LF CLK to detect UBS bus reset. */
                  USBUART_BUS_RST_CNT_REG = USBUART_DEFUALT_BUS_RST_CNT;
              
                  /* Select VBUS detection source and clear PHY isolate. The application level
                  * must ensure that VBUS is valid. There is no need to wait 2us before VBUS is valid.
                  */
                  USBUART_POWER_CTRL_REG = USBUART_DEFAULT_POWER_CTRL_VBUS;
              
                  /* Enable PHY detector and single-ended and differential receivers. */
                  USBUART_POWER_CTRL_REG |= USBUART_DEFAULT_POWER_CTRL_PHY;
              
                  /* Suspend clear sequence. */
                  USBUART_POWER_CTRL_REG &= (uint32) ~USBUART_POWER_CTRL_SUSPEND;
                  CyDelayUs(USBUART_WAIT_SUSPEND_DEL_DISABLE);
                  USBUART_POWER_CTRL_REG &= (uint32) ~USBUART_POWER_CTRL_SUSPEND_DEL;
              
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 5   

                  /* Sets IMO lock options and clear all other bits. */
                  USBUART_CR1_REG = USBUART_DEFUALT_CR1;
              
                  /* Configure level (hi, lo, med) for each interrupt source. */
                  USBUART_INTR_LVL_SEL_REG = USBUART_DEFAULT_INTR_LVL_SEL;
              
                  /* Configure interrupt sources from: SOF, Bus Reset and EP0. */
                  USBUART_INTR_SIE_MASK_REG = USBUART_DEFAULT_INTR_SIE_MASK;
              
              #else
 250   1          uint8 enableInterrupts = CyEnterCriticalSection();
 251   1      
 252   1      #if (USBUART_EP_MANAGEMENT_DMA)
                  uint16 i;
              #endif /* (USBUART_EP_MANAGEMENT_DMA) */
 255   1      
 256   1          /* Enable USB block. */
 257   1          USBUART_PM_ACT_CFG_REG |= USBUART_PM_ACT_EN_FSUSB;
 258   1          /* Enable USB block for Standby Power Mode. */
 259   1          USBUART_PM_STBY_CFG_REG |= USBUART_PM_STBY_EN_FSUSB;
 260   1      
 261   1          /* Enable core clock. */
 262   1          USBUART_USB_CLK_EN_REG = USBUART_USB_CLK_ENABLE;
 263   1      
 264   1          USBUART_CR1_REG = USBUART_CR1_ENABLE_LOCK;
 265   1      
 266   1          /* ENABLING USBIO PADS IN USB MODE FROM I/O MODE. */
 267   1          /* Ensure USB transmit enable is low (USB_USBIO_CR0.ten). - Manual Transmission - Disabled. */
 268   1          USBUART_USBIO_CR0_REG &= (uint8) ~USBUART_USBIO_CR0_TEN;
 269   1          CyDelayUs(USBUART_WAIT_REG_STABILITY_50NS);  /* ~50ns delay. */
 270   1          /* Disable USBIO by asserting PM.USB_CR0.fsusbio_pd_n(Inverted.
 271   1          *  high. These bits will be set low by the power manager out-of-reset.
 272   1          *  Also confirm USBIO pull-up is disabled.
 273   1          */
 274   1          USBUART_PM_USB_CR0_REG &= (uint8) ~(USBUART_PM_USB_CR0_PD_N |
 275   1                                                       USBUART_PM_USB_CR0_PD_PULLUP_N);
 276   1      
 277   1          /* Select IOMODE to USB mode. */
 278   1          USBUART_USBIO_CR1_REG &= (uint8) ~USBUART_USBIO_CR1_IOMODE;
 279   1      
 280   1          /* Enable USBIO reference by setting PM.USB_CR0.fsusbio_ref_en. */
 281   1          USBUART_PM_USB_CR0_REG |= USBUART_PM_USB_CR0_REF_EN;
 282   1          /* Reference is available for 1us after regulator is enabled. */
 283   1          CyDelayUs(USBUART_WAIT_REG_STABILITY_1US);
 284   1          /* OR 40us after power is restored. */
 285   1          CyDelayUs(USBUART_WAIT_VREF_RESTORE);
 286   1          /* Ensure single-ended disable bits are low (PRT15.INP_DIS[7:6])(input receiver enabled). */
 287   1          USBUART_DM_INP_DIS_REG &= (uint8) ~USBUART_DM_MASK;
 288   1          USBUART_DP_INP_DIS_REG &= (uint8) ~USBUART_DP_MASK;
 289   1      
 290   1          /* Enable USBIO. */
 291   1          USBUART_PM_USB_CR0_REG |= USBUART_PM_USB_CR0_PD_N;
 292   1          CyDelayUs(USBUART_WAIT_PD_PULLUP_N_ENABLE);
 293   1          /* Set USBIO pull-up enable. */
 294   1          USBUART_PM_USB_CR0_REG |= USBUART_PM_USB_CR0_PD_PULLUP_N;
 295   1      
 296   1          /* Reset Arbiter Write Address register for endpoint 1. */
 297   1          CY_SET_REG8(USBUART_ARB_RW1_WA_PTR,     0u);
 298   1          CY_SET_REG8(USBUART_ARB_RW1_WA_MSB_PTR, 0u);
 299   1      
 300   1      #if (USBUART_EP_MANAGEMENT_DMA)
                  /* Initialize transfer descriptor. This will be used to detect DMA state - initialized or not. */
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 6   

                  for (i = 0u; i < USBUART_MAX_EP; ++i)
                  {
                      USBUART_DmaTd[i] = DMA_INVALID_TD;
              
                  #if (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u))
                      USBUART_DmaNextTd[i] = DMA_INVALID_TD;
                  #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u)) */
                  }
              #endif /* (USBUART_EP_MANAGEMENT_DMA) */
 311   1      
 312   1          CyExitCriticalSection(enableInterrupts);
 313   1      #endif /* (CY_PSOC4) */
 314   1      
 315   1          /* Configure interrupts from USB block. */
 316   1      #if (CY_PSOC4)
                  /* Configure hi_int: set handler and priority. */
                  CyIntSetPriority     (USBUART_INTR_HI_VECT_NUM,  USBUART_INTR_HI_PRIORITY);
                  (void) CyIntSetVector(USBUART_INTR_HI_VECT_NUM, &USBUART_INTR_HI_ISR);
              
                  /* Configure lo_int: set handler and priority. */
                  CyIntSetPriority     (USBUART_INTR_LO_VECT_NUM,  USBUART_INTR_LO_PRIORITY);
                  (void) CyIntSetVector(USBUART_INTR_LO_VECT_NUM, &USBUART_INTR_LO_ISR);
              
                  /* Configure med_int: set handler and priority (routed through DSI). */
                  CyIntSetPriority     (USBUART_INTR_MED_VECT_NUM,  USBUART_INTR_MED_PRIORITY);
                  (void) CyIntSetVector(USBUART_INTR_MED_VECT_NUM, &USBUART_INTR_MED_ISR);
              
              #else
 330   1          /* Set bus reset interrupt. */
 331   1          CyIntSetPriority(USBUART_BUS_RESET_VECT_NUM, USBUART_BUS_RESET_PRIOR);
 332   1          (void) CyIntSetVector(USBUART_BUS_RESET_VECT_NUM,   &USBUART_BUS_RESET_ISR);
 333   1      
 334   1          /* Set Control Endpoint Interrupt. */
 335   1          CyIntSetPriority(USBUART_EP_0_VECT_NUM, USBUART_EP_0_PRIOR);
 336   1          (void) CyIntSetVector(USBUART_EP_0_VECT_NUM,   &USBUART_EP_0_ISR);
 337   1      
 338   1          /* Set SOF interrupt. */
 339   1          #if (USBUART_SOF_ISR_ACTIVE)
 340   1              CyIntSetPriority     (USBUART_SOF_VECT_NUM,  USBUART_SOF_PRIOR);
 341   1              (void) CyIntSetVector(USBUART_SOF_VECT_NUM, &USBUART_SOF_ISR);
 342   1          #endif /* (USBUART_SOF_ISR_ACTIVE) */
 343   1      
 344   1          /* Set Data Endpoint 1 Interrupt. */
 345   1          #if (USBUART_EP1_ISR_ACTIVE)
 346   1              CyIntSetPriority     (USBUART_EP_1_VECT_NUM,  USBUART_EP_1_PRIOR);
 347   1              (void) CyIntSetVector(USBUART_EP_1_VECT_NUM,  &USBUART_EP_1_ISR);
 348   1          #endif /* (USBUART_EP1_ISR_ACTIVE) */
 349   1      
 350   1          /* Set Data Endpoint 2 Interrupt. */
 351   1          #if (USBUART_EP2_ISR_ACTIVE)
 352   1              CyIntSetPriority     (USBUART_EP_2_VECT_NUM,  USBUART_EP_2_PRIOR);
 353   1              (void) CyIntSetVector(USBUART_EP_2_VECT_NUM, &USBUART_EP_2_ISR);
 354   1          #endif /* (USBUART_EP2_ISR_ACTIVE) */
 355   1      
 356   1          /* Set Data Endpoint 3 Interrupt. */
 357   1          #if (USBUART_EP3_ISR_ACTIVE)
 358   1              CyIntSetPriority     (USBUART_EP_3_VECT_NUM,  USBUART_EP_3_PRIOR);
 359   1              (void) CyIntSetVector(USBUART_EP_3_VECT_NUM, &USBUART_EP_3_ISR);
 360   1          #endif /* (USBUART_EP3_ISR_ACTIVE) */
 361   1      
 362   1          /* Set Data Endpoint 4 Interrupt. */
 363   1          #if (USBUART_EP4_ISR_ACTIVE)
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 7   

                      CyIntSetPriority     (USBUART_EP_4_VECT_NUM,  USBUART_EP_4_PRIOR);
                      (void) CyIntSetVector(USBUART_EP_4_VECT_NUM, &USBUART_EP_4_ISR);
                  #endif /* (USBUART_EP4_ISR_ACTIVE) */
 367   1      
 368   1          /* Set Data Endpoint 5 Interrupt. */
 369   1          #if (USBUART_EP5_ISR_ACTIVE)
                      CyIntSetPriority     (USBUART_EP_5_VECT_NUM,  USBUART_EP_5_PRIOR);
                      (void) CyIntSetVector(USBUART_EP_5_VECT_NUM, &USBUART_EP_5_ISR);
                  #endif /* (USBUART_EP5_ISR_ACTIVE) */
 373   1      
 374   1          /* Set Data Endpoint 6 Interrupt. */
 375   1          #if (USBUART_EP6_ISR_ACTIVE)
                      CyIntSetPriority     (USBUART_EP_6_VECT_NUM,  USBUART_EP_6_PRIOR);
                      (void) CyIntSetVector(USBUART_EP_6_VECT_NUM, &USBUART_EP_6_ISR);
                  #endif /* (USBUART_EP6_ISR_ACTIVE) */
 379   1      
 380   1           /* Set Data Endpoint 7 Interrupt. */
 381   1          #if (USBUART_EP7_ISR_ACTIVE)
                      CyIntSetPriority     (USBUART_EP_7_VECT_NUM,  USBUART_EP_7_PRIOR);
                      (void) CyIntSetVector(USBUART_EP_7_VECT_NUM, &USBUART_EP_7_ISR);
                  #endif /* (USBUART_EP7_ISR_ACTIVE) */
 385   1      
 386   1          /* Set Data Endpoint 8 Interrupt. */
 387   1          #if (USBUART_EP8_ISR_ACTIVE)
                      CyIntSetPriority     (USBUART_EP_8_VECT_NUM,  USBUART_EP_8_PRIOR);
                      (void) CyIntSetVector(USBUART_EP_8_VECT_NUM, &USBUART_EP_8_ISR);
                  #endif /* (USBUART_EP8_ISR_ACTIVE) */
 391   1      
 392   1          /* Set ARB Interrupt. */
 393   1          #if (USBUART_EP_MANAGEMENT_DMA && USBUART_ARB_ISR_ACTIVE)
                      CyIntSetPriority     (USBUART_ARB_VECT_NUM,  USBUART_ARB_PRIOR);
                      (void) CyIntSetVector(USBUART_ARB_VECT_NUM, &USBUART_ARB_ISR);
                  #endif /* (USBUART_EP_MANAGEMENT_DMA && USBUART_ARB_ISR_ACTIVE) */
 397   1      #endif /* (CY_PSOC4) */
 398   1      
 399   1          /* Common: Configure GPIO interrupt for wakeup. */
 400   1      #if (USBUART_DP_ISR_ACTIVE)
 401   1          CyIntSetPriority     (USBUART_DP_INTC_VECT_NUM,  USBUART_DP_INTC_PRIORITY);
 402   1          (void) CyIntSetVector(USBUART_DP_INTC_VECT_NUM, &USBUART_DP_ISR);
 403   1      #endif /* (USBUART_DP_ISR_ACTIVE) */
 404   1      
 405   1      #if (USBUART_EP_MANAGEMENT_DMA && CY_PSOC4)
                  /* Initialize DMA channels. */
                  USBUART_InitEpDma();
              #endif /* (USBUART_EP_MANAGEMENT_DMA && CY_PSOC4) */
 409   1      }
 410          
 411          
 412          /*******************************************************************************
 413          * Function Name: USBUART_InitComponent
 414          ****************************************************************************//**
 415          *
 416          *   This function initializes the component’s global variables and initiates
 417          *   communication with the host by pull-up D+ line.
 418          *
 419          * \param device:
 420          *   Contains the device number of the desired device descriptor. The device
 421          *   number can be found in the Device Descriptor Tab of "Configure" dialog,
 422          *   under the settings of desired Device Descriptor, in the *Device Number*
 423          *   field.
 424          *  \param mode:
 425          *   The operating voltage. This determines whether the voltage regulator
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 8   

 426          *   is enabled for 5V operation or if pass through mode is used for 3.3V
 427          *   operation. Symbolic names and their associated values are given in the
 428          *   following list.
 429          *
 430          *       *USBUART_3V_OPERATION* - Disable voltage regulator and pass-
 431          *                                      through Vcc for pull-up
 432          *
 433          *       *USBUART_5V_OPERATION* - Enable voltage regulator and use
 434          *                                      regulator for pull-up
 435          *
 436          *       *USBUART_DWR_POWER_OPERATION* - Enable or disable the voltage
 437          *                                      regulator depending on the power supply
 438          *                                      voltage configuration in the DWR tab.
 439          *                                      For PSoC 3/5LP devices, the VDDD supply
 440          *                                      voltage is considered and for PSoC 4A-L,
 441          *                                      the VBUS supply voltage is considered.
 442          *
 443          * \globalvars
 444          *   \ref USBUART_device
 445          *   \ref USBUART_transferState
 446          *   \ref USBUART_configuration
 447          *   \ref USBUART_deviceStatus
 448          *
 449          *   \ref USBUART_deviceAddress - Contains the current device address. This
 450          *       variable is initialized to zero in this API. The Host starts to communicate
 451          *      to the device with address 0 and then sets it to a whatever value using a
 452          *      SET_ADDRESS request.
 453          *
 454          *   \ref USBUART_lastPacketSize - Initialized to 0;
 455          *
 456          * \reentrant
 457          *  No.
 458          *
 459          *******************************************************************************/
 460          void USBUART_InitComponent(uint8 device, uint8 mode) 
 461          {
 462   1          /* Initialize _hidProtocol variable to comply with
 463   1          *  HID 7.2.6 Set_Protocol Request:
 464   1          *  "When initialized, all devices default to report protocol."
 465   1          */
 466   1      #if defined(USBUART_ENABLE_HID_CLASS)
 467   1          uint8 i;
 468   1      
 469   1          for (i = 0u; i < USBUART_MAX_INTERFACES_NUMBER; i++)
 470   1          {
 471   2              USBUART_hidProtocol[i] = USBUART_PROTOCOL_REPORT;
 472   2          }
 473   1      #endif /* USBUART_ENABLE_HID_CLASS */
 474   1      
 475   1          /* Store device number to access descriptor. */
 476   1          USBUART_device = device;
 477   1      
 478   1          /* Reset component internal variables. */
 479   1          USBUART_transferState   = USBUART_TRANS_STATE_IDLE;
 480   1          USBUART_configurationChanged = 0u;
 481   1          USBUART_configuration   = 0u;
 482   1          USBUART_interfaceNumber = 0u;
 483   1          USBUART_deviceAddress   = 0u;
 484   1          USBUART_deviceStatus    = 0u;
 485   1          USBUART_lastPacketSize  = 0u;
 486   1      
 487   1          /* Enable component interrupts. */
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 9   

 488   1      #if (CY_PSOC4)
                  CyIntEnable(USBUART_INTR_HI_VECT_NUM);
                  CyIntEnable(USBUART_INTR_MED_VECT_NUM);
                  CyIntEnable(USBUART_INTR_LO_VECT_NUM);
              #else
 493   1          CyIntEnable(USBUART_BUS_RESET_VECT_NUM);
 494   1          CyIntEnable(USBUART_EP_0_VECT_NUM);
 495   1      
 496   1          #if (USBUART_SOF_ISR_ACTIVE)
 497   1              CyIntEnable(USBUART_SOF_VECT_NUM);
 498   1          #endif /* (USBUART_SOF_ISR_ACTIVE) */
 499   1      
 500   1          #if (USBUART_EP1_ISR_ACTIVE)
 501   1              CyIntEnable(USBUART_EP_1_VECT_NUM);
 502   1          #endif /* (USBUART_EP1_ISR_ACTIVE) */
 503   1      
 504   1          #if (USBUART_EP2_ISR_ACTIVE)
 505   1              CyIntEnable(USBUART_EP_2_VECT_NUM);
 506   1          #endif /* (USBUART_EP5_ISR_ACTIVE) */
 507   1      
 508   1          #if (USBUART_EP3_ISR_ACTIVE)
 509   1              CyIntEnable(USBUART_EP_3_VECT_NUM);
 510   1          #endif /* (USBUART_EP5_ISR_ACTIVE) */
 511   1      
 512   1          #if (USBUART_EP4_ISR_ACTIVE)
                      CyIntEnable(USBUART_EP_4_VECT_NUM);
                  #endif /* (USBUART_EP5_ISR_ACTIVE) */
 515   1      
 516   1          #if (USBUART_EP5_ISR_ACTIVE)
                      CyIntEnable(USBUART_EP_5_VECT_NUM);
                  #endif /* (USBUART_EP5_ISR_ACTIVE) */
 519   1      
 520   1          #if (USBUART_EP6_ISR_ACTIVE)
                      CyIntEnable(USBUART_EP_6_VECT_NUM);
                  #endif /* USBUART_EP6_ISR_REMOVE */
 523   1      
 524   1          #if (USBUART_EP7_ISR_ACTIVE)
                      CyIntEnable(USBUART_EP_7_VECT_NUM);
                  #endif /* (USBUART_EP7_ISR_ACTIVE) */
 527   1      
 528   1          #if (USBUART_EP8_ISR_ACTIVE)
                      CyIntEnable(USBUART_EP_8_VECT_NUM);
                  #endif /* (USBUART_EP8_ISR_ACTIVE) */
 531   1      #endif /* (CY_PSOC4) */
 532   1      
 533   1      #if (USBUART_EP_MANAGEMENT_DMA && USBUART_ARB_ISR_ACTIVE)
                  /* Enable ARB EP interrupt sources. */
                  USBUART_ARB_INT_EN_REG = USBUART_DEFAULT_ARB_INT_EN;
              
                  #if (CY_PSOC3 || CY_PSOC5)
                      CyIntEnable(USBUART_ARB_VECT_NUM);
                  #endif /* (CY_PSOC3 || CY_PSOC5) */
              #endif   /* (USBUART_EP_MANAGEMENT_DMA && USBUART_ARB_ISR_ACTIVE) */
 541   1      
 542   1      /* Arbiter configuration for DMA transfers. */
 543   1      #if (USBUART_EP_MANAGEMENT_DMA)
                  /* Configure Arbiter for Manual or Auto DMA operation and clear configuration completion. */
                  USBUART_ARB_CFG_REG = USBUART_DEFAULT_ARB_CFG;
              
                  #if (CY_PSOC4)
                      /* Enable DMA operation. */
                      CyDmaEnable();
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 10  

              
                      #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
                          /* Change DMA priority to be highest. */
                           CyIntSetPriority(CYDMA_INTR_NUMBER, USBUART_DMA_AUTO_INTR_PRIO);
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (CY_PSOC4) */
              
                  #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
                      #if (CY_PSOC4)
                          /* Enable DMA interrupt to handle DMA management. */
                          CyIntEnable(CYDMA_INTR_NUMBER);
                      #else
                          #if (USBUART_EP_DMA_AUTO_OPT == 0u)
                              /* Initialize interrupts which handle verification of successful DMA transaction. */
                              USBUART_EP_DMA_Done_isr_StartEx(&USBUART_EP_DMA_DONE_ISR);
                              USBUART_EP17_DMA_Done_SR_InterruptEnable();
                              USBUART_EP8_DMA_Done_SR_InterruptEnable();
                          #endif /* (USBUART_EP_DMA_AUTO_OPT == 0u) */
                      #endif /* (CY_PSOC4) */
                  #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
              #endif /* (USBUART_EP_MANAGEMENT_DMA) */
 571   1      
 572   1          /* Enable USB regulator depends on operation voltage. IMO Locking is enabled in Init(). */
 573   1          switch(mode)
 574   1          {
 575   2          case USBUART_3V_OPERATION:
 576   2              /* Disable regulator for 3V operation. */
 577   2              USBUART_CR1_REG &= (uint8) ~USBUART_CR1_REG_ENABLE;
 578   2              break;
 579   2      
 580   2          case USBUART_5V_OPERATION:
 581   2              /* Enable regulator for 5V operation. */
 582   2              USBUART_CR1_REG |= (uint8)  USBUART_CR1_REG_ENABLE;
 583   2              break;
 584   2      
 585   2          default: /* Check DWR settings of USB power supply. */
 586   2          #if (USBUART_VDDD_MV < USBUART_3500MV)
                      /* Disable regulator for 3V operation. */
                      USBUART_CR1_REG &= (uint8) ~USBUART_CR1_REG_ENABLE;
                  #else
 590   2              /* Enable regulator for 5V operation. */
 591   2              USBUART_CR1_REG |= (uint8)  USBUART_CR1_REG_ENABLE;
 592   2          #endif /* (USBUART_VDDD_MV < USBUART_3500MV) */
 593   2              break;
 594   2          }
 595   1      
 596   1      #if (CY_PSOC4)
                  /* Clear bus activity. */
                  USBUART_CR1_REG &= (uint32) ~USBUART_CR1_BUS_ACTIVITY;
              
                  /* Clear EP0 count register. */
                  USBUART_EP0_CNT_REG = USBUART_CLEAR_REG;
              
                  /* Set EP0.CR: ACK Setup, NAK IN/OUT. */
                  USBUART_EP0_CR_REG = USBUART_MODE_NAK_IN_OUT;
              
                  #if (USBUART_LPM_ACTIVE)
                      if (NULL != USBUART_GetBOSPtr())
                      {
                          /* Enable LPM and acknowledge LPM packets for active device.
                          * Reset NYET_EN and SUB_RESP bits in the LPM_CTRL register.
                          */
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 11  

                          USBUART_LPM_CTRL_REG = (USBUART_LPM_CTRL_LPM_EN | \
                                                           USBUART_LPM_CTRL_LPM_ACK_RESP);
                      }
                      else
                      {
                          /* Disable LPM for active device. */
                          USBUART_LPM_CTRL_REG &= (uint32) ~USBUART_LPM_CTRL_LPM_EN;
                      }
                  #endif /* (USBUART_LPM_ACTIVE) */
              
                  /* Enable device to responds to USB traffic with address 0. */
                  USBUART_CR0_REG = USBUART_DEFUALT_CR0;
              
              #else
 626   1          /* Set EP0.CR: ACK Setup, STALL IN/OUT. */
 627   1          USBUART_EP0_CR_REG = USBUART_MODE_STALL_IN_OUT;
 628   1      
 629   1          /* Enable device to respond to USB traffic with address 0. */
 630   1          USBUART_CR0_REG = USBUART_DEFUALT_CR0;
 631   1          CyDelayCycles(USBUART_WAIT_CR0_REG_STABILITY);
 632   1      #endif /* (CY_PSOC4) */
 633   1      
 634   1          /* Enable D+ pull-up and keep USB control on IO. */
 635   1          USBUART_USBIO_CR1_REG = USBUART_USBIO_CR1_USBPUEN;
 636   1      }
 637          
 638          
 639          /*******************************************************************************
 640          * Function Name: USBUART_ReInitComponent
 641          ****************************************************************************//**
 642          *
 643          *  This function reinitialize the component configuration and is
 644          *  intend to be called from the Reset interrupt.
 645          *
 646          * \globalvars
 647          *   USBUART_device - Contains the device number of the desired Device
 648          *        Descriptor. The device number can be found in the Device Descriptor tab
 649          *       of the Configure dialog, under the settings of the desired Device Descriptor,
 650          *       in the Device Number field.
 651          *   USBUART_transferState - This variable is used by the communication
 652          *       functions to handle the current transfer state. Initialized to
 653          *       TRANS_STATE_IDLE in this API.
 654          *   USBUART_configuration - Contains the current configuration number
 655          *       set by the Host using a SET_CONFIGURATION request.
 656          *       Initialized to zero in this API.
 657          *   USBUART_deviceAddress - Contains the current device address. This
 658          *       variable is initialized to zero in this API. The Host starts to communicate
 659          *      to the device with address 0 and then sets it to a whatever value using
 660          *      a SET_ADDRESS request.
 661          *   USBUART_deviceStatus - Initialized to 0.
 662          *       This is a two-bit variable which contains the power status in the first bit
 663          *       (DEVICE_STATUS_BUS_POWERED or DEVICE_STATUS_SELF_POWERED) and the remote
 664          *       wakeup status (DEVICE_STATUS_REMOTE_WAKEUP) in the second bit.
 665          *   USBUART_lastPacketSize - Initialized to 0;
 666          *
 667          * \reentrant
 668          *  No.
 669          *
 670          *******************************************************************************/
 671          void USBUART_ReInitComponent(void) 
 672          {
 673   1          /* Initialize _hidProtocol variable to comply with HID 7.2.6 Set_Protocol
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 12  

 674   1          *  Request: "When initialized, all devices default to report protocol."
 675   1          */
 676   1      #if defined(USBUART_ENABLE_HID_CLASS)
 677   1          uint8 i;
 678   1      
 679   1          for (i = 0u; i < USBUART_MAX_INTERFACES_NUMBER; i++)
 680   1          {
 681   2              USBUART_hidProtocol[i] = USBUART_PROTOCOL_REPORT;
 682   2          }
 683   1      #endif /* USBUART_ENABLE_HID_CLASS */
 684   1      
 685   1          /* Reset component internal variables. */
 686   1          USBUART_transferState   = USBUART_TRANS_STATE_IDLE;
 687   1          USBUART_configurationChanged = 0u;
 688   1          USBUART_configuration   = 0u;
 689   1          USBUART_interfaceNumber = 0u;
 690   1          USBUART_deviceAddress   = 0u;
 691   1          USBUART_deviceStatus    = 0u;
 692   1          USBUART_lastPacketSize  = 0u;
 693   1      
 694   1      #if (CY_PSOC4)
                  /* Set EP0.CR: ACK Setup, NAK IN/OUT. */
                  USBUART_EP0_CR_REG = USBUART_MODE_NAK_IN_OUT;
              #else
 698   1          /* Set EP0.CR: ACK Setup, STALL IN/OUT. */
 699   1          USBUART_EP0_CR_REG = USBUART_MODE_STALL_IN_OUT;
 700   1      #endif /* (CY_PSOC4) */
 701   1      
 702   1          /* Enable device to respond to USB traffic with address 0. */
 703   1          USBUART_CR0_REG = USBUART_DEFUALT_CR0;
 704   1      }
 705          
 706          
 707          /*******************************************************************************
 708          * Function Name: USBUART_Stop
 709          ****************************************************************************//**
 710          *
 711          *  This function shuts down the USB function including to release
 712          *  the D+ pull-up and disabling the SIE.
 713          *
 714          * \globalvars
 715          *   \ref USBUART_configuration
 716          *
 717          *   USBUART_deviceAddress - Contains the current device address. This
 718          *       variable is initialized to zero in this API. The Host starts to communicate
 719          *      to the device with address 0 and then sets it to a whatever value using
 720          *      a SET_ADDRESS request.
 721          *
 722          *   \ref USBUART_deviceStatus
 723          *
 724          *   \ref USBUART_configurationChanged
 725          *
 726          *   USBUART_intiVar -  This variable is set to zero
 727          *
 728          *******************************************************************************/
 729          void USBUART_Stop(void) 
 730          {
 731   1          uint8 enableInterrupts;
 732   1      
 733   1      #if (USBUART_EP_MANAGEMENT_DMA)
                  /* Stop all DMA channels. */
                  USBUART_Stop_DMA(USBUART_MAX_EP);
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 13  

              #endif /* (USBUART_EP_MANAGEMENT_DMA) */
 737   1      
 738   1          enableInterrupts = CyEnterCriticalSection();
 739   1      
 740   1          /* Disable USB IP to respond to USB traffic. */
 741   1          USBUART_CR0_REG &= (uint8) ~USBUART_CR0_ENABLE;
 742   1      
 743   1          /* Disable D+ pull-up. */
 744   1          USBUART_USBIO_CR1_REG &= (uint8) ~ USBUART_USBIO_CR1_USBPUEN;
 745   1      
 746   1      #if (CY_PSOC4)
                  /* Disable USBFS block. */
                  USBUART_POWER_CTRL_REG &= (uint32) ~USBUART_POWER_CTRL_ENABLE;
              #else
 750   1          /* Clear power active and standby mode templates. */
 751   1          USBUART_PM_ACT_CFG_REG  &= (uint8) ~USBUART_PM_ACT_EN_FSUSB;
 752   1          USBUART_PM_STBY_CFG_REG &= (uint8) ~USBUART_PM_STBY_EN_FSUSB;
 753   1      
 754   1          /* Ensure single-ended disable bits are high (PRT15.INP_DIS[7:6])
 755   1           * (input receiver disabled). */
 756   1          USBUART_DM_INP_DIS_REG |= (uint8) USBUART_DM_MASK;
 757   1          USBUART_DP_INP_DIS_REG |= (uint8) USBUART_DP_MASK;
 758   1      
 759   1      #endif /* (CY_PSOC4) */
 760   1      
 761   1          CyExitCriticalSection(enableInterrupts);
 762   1      
 763   1          /* Disable component interrupts. */
 764   1      #if (CY_PSOC4)
                  CyIntDisable(USBUART_INTR_HI_VECT_NUM);
                  CyIntDisable(USBUART_INTR_LO_VECT_NUM);
                  CyIntDisable(USBUART_INTR_MED_VECT_NUM);
              #else
 769   1      
 770   1          CyIntDisable(USBUART_BUS_RESET_VECT_NUM);
 771   1          CyIntDisable(USBUART_EP_0_VECT_NUM);
 772   1      
 773   1          #if (USBUART_SOF_ISR_ACTIVE)
 774   1              CyIntDisable(USBUART_SOF_VECT_NUM);
 775   1          #endif /* (USBUART_SOF_ISR_ACTIVE) */
 776   1      
 777   1          #if (USBUART_EP1_ISR_ACTIVE)
 778   1              CyIntDisable(USBUART_EP_1_VECT_NUM);
 779   1          #endif /* (USBUART_EP1_ISR_ACTIVE) */
 780   1      
 781   1          #if (USBUART_EP2_ISR_ACTIVE)
 782   1              CyIntDisable(USBUART_EP_2_VECT_NUM);
 783   1          #endif /* (USBUART_EP2_ISR_ACTIVE) */
 784   1      
 785   1          #if (USBUART_EP3_ISR_ACTIVE)
 786   1              CyIntDisable(USBUART_EP_3_VECT_NUM);
 787   1          #endif /* (USBUART_EP3_ISR_ACTIVE) */
 788   1      
 789   1          #if (USBUART_EP4_ISR_ACTIVE)
                      CyIntDisable(USBUART_EP_4_VECT_NUM);
                  #endif /* (USBUART_EP4_ISR_ACTIVE) */
 792   1      
 793   1          #if (USBUART_EP5_ISR_ACTIVE)
                      CyIntDisable(USBUART_EP_5_VECT_NUM);
                  #endif /* (USBUART_EP5_ISR_ACTIVE) */
 796   1      
 797   1          #if (USBUART_EP6_ISR_ACTIVE)
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 14  

                      CyIntDisable(USBUART_EP_6_VECT_NUM);
                  #endif /* USBUART_EP6_ISR_REMOVE */
 800   1      
 801   1          #if (USBUART_EP7_ISR_ACTIVE)
                      CyIntDisable(USBUART_EP_7_VECT_NUM);
                  #endif /* (USBUART_EP7_ISR_ACTIVE) */
 804   1      
 805   1          #if (USBUART_EP8_ISR_ACTIVE)
                      CyIntDisable(USBUART_EP_8_VECT_NUM);
                  #endif /* (USBUART_EP8_ISR_ACTIVE) */
 808   1      
 809   1          #if (USBUART_DP_ISR_ACTIVE)
 810   1              /* Clear active mode Dp interrupt source history. */
 811   1              (void) USBUART_Dp_ClearInterrupt();
 812   1              CyIntClearPending(USBUART_DP_INTC_VECT_NUM);
 813   1          #endif /* (USBUART_DP_ISR_ACTIVE). */
 814   1      
 815   1      #endif /* (CY_PSOC4) */
 816   1      
 817   1          /* Reset component internal variables. */
 818   1          USBUART_configurationChanged = 0u;
 819   1          USBUART_configuration   = 0u;
 820   1          USBUART_interfaceNumber = 0u;
 821   1          USBUART_deviceAddress   = 0u;
 822   1          USBUART_deviceStatus    = 0u;
 823   1      
 824   1          /* It is mandatory for correct device startup. */
 825   1          USBUART_initVar = 0u;
 826   1      }
 827          
 828          
 829          /*******************************************************************************
 830          * Function Name: USBUART_CheckActivity
 831          ****************************************************************************//**
 832          *
 833          *  This function returns the activity status of the bus. It clears the hardware
 834          *  status to provide updated status on the next call of this function. It
 835          *  provides a way to determine whether any USB bus activity occurred. The
 836          *  application should use this function to determine if the USB suspend
 837          *  conditions are met.
 838          *
 839          *
 840          * \return
 841          *  cystatus: Status of the bus since the last call of the function.
 842          *  Return Value |   Description
 843          *  -------------|---------------------------------------------------------------
 844          *  1            |Bus activity was detected since the last call to this function
 845          *  0            |Bus activity was not detected since the last call to this function
 846          *
 847          *
 848          *******************************************************************************/
 849          uint8 USBUART_CheckActivity(void) 
 850          {
 851   1          uint8 cr1Reg = USBUART_CR1_REG;
 852   1      
 853   1          /* Clear bus activity. */
 854   1          USBUART_CR1_REG = (cr1Reg & (uint8) ~USBUART_CR1_BUS_ACTIVITY);
 855   1      
 856   1          /* Get bus activity. */
 857   1          return ((0u != (cr1Reg & USBUART_CR1_BUS_ACTIVITY)) ? (1u) : (0u));
 858   1      }
 859          
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 15  

 860          
 861          /*******************************************************************************
 862          * Function Name: USBUART_GetConfiguration
 863          ****************************************************************************//**
 864          *
 865          *  This function gets the current configuration of the USB device.
 866          *
 867          * \return
 868          *  Returns the currently assigned configuration. Returns 0 if the device
 869          *  is not configured
 870          *
 871          *******************************************************************************/
 872          uint8 USBUART_GetConfiguration(void) 
 873          {
 874   1          return (USBUART_configuration);
 875   1      }
 876          
 877          
 878          /*******************************************************************************
 879          * Function Name: USBUART_IsConfigurationChanged
 880          ****************************************************************************//**
 881          *
 882          *  This function returns the clear-on-read configuration state.  It is useful
 883          *  when the host sends double SET_CONFIGURATION request with the same 
 884          *  configuration number or changes alternate settings of the interface. 
 885          *  After configuration has been changed the OUT endpoints must be enabled and IN 
 886          *  endpoint must be loaded with data to start communication with the host.
 887          *
 888          * \return
 889          *  None-zero value when new configuration has been changed, otherwise zero is
 890          *  returned.
 891          *
 892          * \globalvars
 893          *
 894          *  \ref USBUART_configurationChanged - This variable is set to 1 after
 895          *   a SET_CONFIGURATION request and cleared in this function.
 896          *
 897          *******************************************************************************/
 898          uint8 USBUART_IsConfigurationChanged(void) 
 899          {
 900   1          uint8 res = 0u;
 901   1      
 902   1          if (USBUART_configurationChanged != 0u)
 903   1          {
 904   2              res = USBUART_configurationChanged;
 905   2              USBUART_configurationChanged = 0u;
 906   2          }
 907   1      
 908   1          return (res);
 909   1      }
 910          
 911          
 912          /*******************************************************************************
 913          * Function Name: USBUART_GetInterfaceSetting
 914          ****************************************************************************//**
 915          *
 916          *  This function gets the current alternate setting for the specified interface.
 917          *  It is useful to identify which alternate settings are active in the specified 
 918          *  interface.
 919          *
 920          *  \param
 921          *  interfaceNumber interface number
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 16  

 922          *
 923          * \return
 924          *  Returns the current alternate setting for the specified interface.
 925          *
 926          *******************************************************************************/
 927          uint8  USBUART_GetInterfaceSetting(uint8 interfaceNumber)
 928                                                              
 929          {
 930   1          return (USBUART_interfaceSetting[interfaceNumber]);
 931   1      }
 932          
 933          
 934          /*******************************************************************************
 935          * Function Name: USBUART_GetEPState
 936          ****************************************************************************//**
 937          *
 938          *  This function returns the state of the requested endpoint.
 939          *
 940          * \param epNumber Data endpoint number
 941          *
 942          * \return
 943          *  Returns the current state of the specified USBFS endpoint. Symbolic names and
 944          *  their associated values are given in the following table. Use these constants
 945          *  whenever you write code to change the state of the endpoints, such as ISR
 946          *  code, to handle data sent or received.
 947          *
 948          *  Return Value           | Description
 949          *  -----------------------|-----------------------------------------------------
 950          *  USBFS_NO_EVENT_PENDING |The endpoint is awaiting SIE action
 951          *  USBFS_EVENT_PENDING    |The endpoint is awaiting CPU action
 952          *  USBFS_NO_EVENT_ALLOWED |The endpoint is locked from access
 953          *  USBFS_IN_BUFFER_FULL   |The IN endpoint is loaded and the mode is set to ACK IN
 954          *  USBFS_IN_BUFFER_EMPTY  |An IN transaction occurred and more data can be loaded
 955          *  USBFS_OUT_BUFFER_EMPTY |The OUT endpoint is set to ACK OUT and is waiting for data
 956          *  USBFS_OUT_BUFFER_FULL  |An OUT transaction has occurred and data can be read
 957          *
 958          *******************************************************************************/
 959          uint8 USBUART_GetEPState(uint8 epNumber) 
 960          {
 961   1          return (USBUART_EP[epNumber].apiEpState);
 962   1      }
 963          
 964          
 965          /*******************************************************************************
 966          * Function Name: USBUART_GetEPCount
 967          ****************************************************************************//**
 968          *
 969          *  This function supports Data Endpoints only(EP1-EP8).
 970          *  Returns the transfer count for the requested endpoint.  The value from
 971          *  the count registers includes 2 counts for the two byte checksum of the
 972          *  packet.  This function subtracts the two counts.
 973          *
 974          *  \param epNumber Data Endpoint Number.
 975          *                   Valid values are between 1 and 8.
 976          *
 977          * \return
 978          *  Returns the current byte count from the specified endpoint or 0 for an
 979          *  invalid endpoint.
 980          *
 981          *******************************************************************************/
 982          uint16 USBUART_GetEPCount(uint8 epNumber) 
 983          {
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 17  

 984   1          uint16 cntr = 0u;
 985   1      
 986   1          if ((epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
 987   1          {
 988   2              /* Get 11-bits EP counter where epCnt0 - 3 bits MSB and epCnt1 - 8 bits LSB. */
 989   2              cntr  = ((uint16) USBUART_SIE_EP_BASE.sieEp[epNumber].epCnt0) & USBUART_EPX_CNT0_MASK;
 990   2              cntr  = ((uint16) (cntr << 8u)) | ((uint16) USBUART_SIE_EP_BASE.sieEp[epNumber].epCnt1);
 991   2              cntr -= USBUART_EPX_CNTX_CRC_COUNT;
 992   2          }
 993   1      
 994   1          return (cntr);
 995   1      }
 996          
 997          
 998          #if (USBUART_EP_MANAGEMENT_DMA)
              #if (CY_PSOC4)
                  /*******************************************************************************
                  * Function Name: USBUART_InitEpDma
                  ****************************************************************************//**
                  *
                  *  This function configures priority for all DMA channels utilized by the
                  *  component. Also sets callbacks for DMA auto mode.
                  *
                  *******************************************************************************/
                  static void USBUART_InitEpDma(void)
                  {
                  #if (USBUART_DMA1_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBUART_ep1_dma_CHANNEL] = USBUART_ep1_dma_CHANNEL_CFG;
                  #endif /* (USBUART_DMA1_ACTIVE) */
              
                  #if (USBUART_DMA2_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBUART_ep2_dma_CHANNEL] = USBUART_ep2_dma_CHANNEL_CFG;
                  #endif /* (USBUART_DMA2_ACTIVE) */
              
                  #if (USBUART_DMA3_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBUART_ep3_dma_CHANNEL] = USBUART_ep3_dma_CHANNEL_CFG;
                  #endif /* (USBUART_DMA3_ACTIVE) */
              
                  #if (USBUART_DMA4_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBUART_ep4_dma_CHANNEL] = USBUART_ep4_dma_CHANNEL_CFG;
                  #endif /* (USBUART_DMA4_ACTIVE) */
              
                  #if (USBUART_DMA5_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBUART_ep5_dma_CHANNEL] = USBUART_ep5_dma_CHANNEL_CFG;
                  #endif /* (USBUART_DMA5_ACTIVE) */
              
                  #if (USBUART_DMA6_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBUART_ep6_dma_CHANNEL] = USBUART_ep6_dma_CHANNEL_CFG;
                  #endif /* (USBUART_DMA6_ACTIVE) */
              
                  #if (USBUART_DMA7_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBUART_ep7_dma_CHANNEL] = USBUART_ep7_dma_CHANNEL_CFG;
                  #endif /* (USBUART_DMA7_ACTIVE) */
              
                  #if (USBUART_DMA8_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBUART_ep8_dma_CHANNEL] = USBUART_ep8_dma_CHANNEL_CFG;
                  #endif /* (USBUART_DMA8_ACTIVE) */
              
                  #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
                      /* Initialize DMA channel callbacks. */
                      #if (USBUART_DMA1_ACTIVE)
                          (void) USBUART_ep1_dma_SetInterruptCallback(&USBUART_EP1_DMA_DONE_ISR);
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 18  

                      #endif /* (USBUART_DMA1_ACTIVE) */
              
                      #if (USBUART_DMA2_ACTIVE)
                          (void) USBUART_ep2_dma_SetInterruptCallback(&USBUART_EP2_DMA_DONE_ISR);
                      #endif /* (USBUART_DMA2_ACTIVE) */
              
                      #if (USBUART_DMA3_ACTIVE)
                          (void) USBUART_ep3_dma_SetInterruptCallback(&USBUART_EP3_DMA_DONE_ISR);
                      #endif /* (USBUART_DMA3_ACTIVE) */
              
                      #if (USBUART_DMA4_ACTIVE)
                          (void) USBUART_ep4_dma_SetInterruptCallback(&USBUART_EP4_DMA_DONE_ISR);
                      #endif /* (USBUART_DMA4_ACTIVE) */
              
                      #if (USBUART_DMA5_ACTIVE)
                          (void) USBUART_ep5_dma_SetInterruptCallback(&USBUART_EP5_DMA_DONE_ISR);
                      #endif /* (USBUART_DMA5_ACTIVE) */
              
                      #if (USBUART_DMA6_ACTIVE)
                          (void) USBUART_ep6_dma_SetInterruptCallback(&USBUART_EP6_DMA_DONE_ISR);
                      #endif /* (USBUART_DMA6_ACTIVE) */
              
                      #if (USBUART_DMA7_ACTIVE)
                          (void) USBUART_ep7_dma_SetInterruptCallback(&USBUART_EP7_DMA_DONE_ISR);
                      #endif /* (USBUART_DMA7_ACTIVE) */
              
                      #if (USBUART_DMA8_ACTIVE)
                          (void) USBUART_ep8_dma_SetInterruptCallback(&USBUART_EP8_DMA_DONE_ISR);
                      #endif /* (USBUART_DMA8_ACTIVE) */
                  #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                  }
              #else
              
              
                  /***************************************************************************
                  * Function Name: USBUART_InitEP_DMA
                  ************************************************************************//**
                  *
                  *  This function allocates and initializes a DMA channel to be used by the
                  *  USBUART_LoadInEP() or USBUART_ReadOutEP() APIs for data
                  *  transfer. It is available when the Endpoint Memory Management parameter
                  *  is set to DMA.
                  *
                  *  This function is automatically called from the USBFS_LoadInEP() and USBFS_ReadOutEP() APIs.
                  *
                  *  \param epNumber Contains the data endpoint number.
                  *            Valid values are between 1 and 8.
                  *  \param *pData Pointer to a data array that is related to the EP transfers.
                  *
                  * \reentrant No.
                  *
                  ***************************************************************************/
                  void USBUART_InitEP_DMA(uint8 epNumber, const uint8 *pData)
                                                                                  
                  {
                      uint16 src;
                      uint16 dst;
              
                  #if (CY_PSOC3)
                      src = HI16(CYDEV_SRAM_BASE);
                      dst = HI16(CYDEV_PERIPH_BASE);
                      pData = pData;
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 19  

                  #else
                      if ((USBUART_EP[epNumber].addr & USBUART_DIR_IN) != 0u)
                      {
                          /* IN endpoint: source is memory buffer. */
                          src = HI16(pData);
                          dst = HI16(CYDEV_PERIPH_BASE);
                      }
                      else
                      {
                          /* OUT endpoint: source is USB IP memory buffer. */
                          src = HI16(CYDEV_PERIPH_BASE);
                          dst = HI16(pData);
                      }
                  #endif  /* (CY_PSOC3) */
              
                      switch(epNumber)
                      {
                  #if (USBUART_DMA1_ACTIVE)
                      case USBUART_EP1:
                          USBUART_DmaChan[epNumber] = USBUART_ep1_DmaInitialize(USBUART_DMA_BYTES_PER_BURST,
                                                                                                  USBUART_DMA_REQUEST_PE
             -R_BURST, src, dst);
                          break;
                  #endif /* (USBUART_DMA1_ACTIVE) */
              
                  #if (USBUART_DMA2_ACTIVE)
                      case USBUART_EP2:
                          USBUART_DmaChan[epNumber] = USBUART_ep2_DmaInitialize(USBUART_DMA_BYTES_PER_BURST,
                                                                                                  USBUART_DMA_REQUEST_PE
             -R_BURST, src, dst);
                          break;
                  #endif /* (USBUART_DMA2_ACTIVE) */
              
                  #if (USBUART_DMA3_ACTIVE)
                          case USBUART_EP3:
                              USBUART_DmaChan[epNumber] = USBUART_ep3_DmaInitialize(USBUART_DMA_BYTES_PER_BURST,
                                                                                                      USBUART_DMA_REQUES
             -T_PER_BURST, src, dst);
                          break;
                  #endif /* (USBUART_DMA3_ACTIVE) */
              
                  #if (USBUART_DMA4_ACTIVE)
                          case USBUART_EP4:
                              USBUART_DmaChan[epNumber] = USBUART_ep4_DmaInitialize(USBUART_DMA_BYTES_PER_BURST,
                                                                                                      USBUART_DMA_REQUES
             -T_PER_BURST, src, dst);
                          break;
                  #endif /* (USBUART_DMA4_ACTIVE) */
              
                  #if (USBUART_DMA5_ACTIVE)
                          case USBUART_EP5:
                              USBUART_DmaChan[epNumber] = USBUART_ep5_DmaInitialize(USBUART_DMA_BYTES_PER_BURST,
                                                                                                      USBUART_DMA_REQUES
             -T_PER_BURST, src, dst);
                          break;
                  #endif /* (USBUART_DMA5_ACTIVE) */
              
                  #if (USBUART_DMA6_ACTIVE)
                      case USBUART_EP6:
                          USBUART_DmaChan[epNumber] = USBUART_ep6_DmaInitialize(USBUART_DMA_BYTES_PER_BURST,
                                                                                                  USBUART_DMA_REQUEST_PE
             -R_BURST, src, dst);
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 20  

                          break;
                  #endif /* (USBUART_DMA6_ACTIVE) */
              
                  #if (USBUART_DMA7_ACTIVE)
                      case USBUART_EP7:
                              USBUART_DmaChan[epNumber] = USBUART_ep7_DmaInitialize(USBUART_DMA_BYTES_PER_BURST,
                                                                                                      USBUART_DMA_REQUES
             -T_PER_BURST, src, dst);
                          break;
                  #endif /* (USBUART_DMA7_ACTIVE) */
              
                  #if (USBUART_DMA8_ACTIVE)
                      case USBUART_EP8:
                              USBUART_DmaChan[epNumber] = USBUART_ep8_DmaInitialize(USBUART_DMA_BYTES_PER_BURST,
                                                                                                      USBUART_DMA_REQUES
             -T_PER_BURST, src, dst);
                          break;
                  #endif /* (USBUART_DMA8_ACTIVE) */
              
                      default:
                          /* Do nothing for endpoints other than 1-8. */
                          break;
                      }
              
                      if ((epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
                      {
                          USBUART_DmaTd[epNumber] = CyDmaTdAllocate();
              
                      #if (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u))
                          USBUART_DmaNextTd[epNumber] = CyDmaTdAllocate();
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u)) */
                      }
                  }
              #endif /* (CY_PSOC4) */
              
                  /***************************************************************************
                  * Function Name: USBUART_Stop_DMA
                  ************************************************************************//**
                  *  
                  *  This function stops DMA channel associated with endpoint. It is available 
                  *  when the Endpoint Buffer Management parameter is set to DMA. Call this 
                  *  function when endpoint direction is changed from IN to OUT or vice versa 
                  *  to trigger DMA re-configuration when USBUART_LoadInEP() or 
                  *  USBUART_ReadOutEP() functions are called the first time. 
                  *  
                  *  \param epNumber: The data endpoint number for which associated DMA 
                  *  channel is stopped. The range of valid values is between 1 and 8. To stop 
                  *  all DMAs associated with endpoints call this function with 
                  *  USBUART_MAX_EP argument.
                  *
                  * \reentrant
                  *  No.
                  *
                  ***************************************************************************/
                  void USBUART_Stop_DMA(uint8 epNumber) 
                  {
                      uint8 i;
              
                      i = (epNumber < USBUART_MAX_EP) ? epNumber : USBUART_EP1;
              
                      do
                      {
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 21  

                      #if (CY_PSOC4)
                          if (0u != USBUART_DmaChan[i])
                          {
                              USBUART_CyDmaChDisable(USBUART_DmaChan[i]);
                          }
                      #else
                          if(USBUART_DmaTd[i] != DMA_INVALID_TD)
                          {
                              (void) CyDmaChDisable(USBUART_DmaChan[i]);
                              CyDmaTdFree(USBUART_DmaTd[i]);
                              USBUART_DmaTd[i] = DMA_INVALID_TD;
                          }
              
                          #if (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u))
                              if(USBUART_DmaNextTd[i] != DMA_INVALID_TD)
                              {
                                  CyDmaTdFree(USBUART_DmaNextTd[i]);
                                  USBUART_DmaNextTd[i] = DMA_INVALID_TD;
                              }
                          #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u)) */
              
                      #endif /* (CY_PSOC4) */
                          i++;
                      }
                      while ((i < USBUART_MAX_EP) && (epNumber == USBUART_MAX_EP));
                  }
              #endif /* (USBUART_EP_MANAGEMENT_DMA) */
1251          
1252          
1253          #if (CY_PSOC3 || CY_PSOC5)
1254          #if (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u))
                  /***************************************************************************
                  * Function Name: USBUART_LoadNextInEP
                  ************************************************************************//**
                  *
                  * Summary:
                  *  This internal function is used for IN endpoint DMA reconfiguration in
                  *  Auto DMA mode.
                  *
                  * Parameters:
                  *  epNumber: Contains the data endpoint number.
                  *  mode:   0 - Configure DMA to send the the rest of data.
                  *          1 - Configure DMA to repeat 2 last bytes of the first burst.
                  *
                  ***************************************************************************/
                  void USBUART_LoadNextInEP(uint8 epNumber, uint8 mode) 
                  {
                      reg16 *convert;
              
                      if (mode == 0u)
                      {
                          /* Configure DMA to send rest of data. */
                          /* CyDmaTdSetConfiguration API is optimized to change transfer length only and configure TD. *
             -/
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBUART_DmaTd[epNumber]].TD0[0u];
                          /* Set transfer length. */
                          CY_SET_REG16(convert, USBUART_inLength[epNumber] - USBUART_DMA_BYTES_PER_BURST);
                          /* CyDmaTdSetAddress API is optimized to change source address only. */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBUART_DmaTd[epNumber]].TD1[0u];
                          CY_SET_REG16(convert, LO16((uint32)USBUART_inDataPointer[epNumber] +
                                                          USBUART_DMA_BYTES_PER_BURST));
                          USBUART_inBufFull[epNumber] = 1u;
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 22  

                      }
                      else
                      {
                          /* Configure DMA to repeat 2 last bytes of the first burst. */
                          /* CyDmaTdSetConfiguration API is optimized to change transfer length only and configure TD. *
             -/
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBUART_DmaTd[epNumber]].TD0[0u];
                          /* Set transfer length. */
                          CY_SET_REG16(convert, USBUART_DMA_BYTES_REPEAT);
                          /* CyDmaTdSetAddress API is optimized to change source address only. */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBUART_DmaTd[epNumber]].TD1[0u];
                          CY_SET_REG16(convert,  LO16((uint32)USBUART_inDataPointer[epNumber] +
                                                 (USBUART_DMA_BYTES_PER_BURST - USBUART_DMA_BYTES_REPEAT)));
                      }
              
                      /* CyDmaChSetInitialTd API is optimized to initialize TD. */
                      CY_DMA_CH_STRUCT_PTR[USBUART_DmaChan[epNumber]].basic_status[1u] = USBUART_DmaTd[epNumber];
                  }
              #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u)) */
1303          #endif /* (CY_PSOC3 || CY_PSOC5) */
1304          
1305          
1306          /*******************************************************************************
1307          * Function Name: USBUART_LoadInEP
1308          ****************************************************************************//**
1309          *
1310          *  This function performs different functionality depending on the Component’s
1311          *  configured Endpoint Buffer Management. This parameter is defined in
1312          *  the Descriptor Root in Component Configure window.
1313          *
1314          *  *Manual (Static/Dynamic Allocation):*
1315          *  This function loads and enables the specified USB data endpoint for an IN
1316          *  data transfer.
1317          *
1318          *  *DMA with Manual Buffer Management:*
1319          *  Configures DMA for a data transfer from system RAM to endpoint buffer.
1320          *  Generates request for a transfer.
1321          *
1322          *  *DMA with Automatic Buffer Management:*
1323          *  Configures DMA. This is required only once, so it is done only when parameter
1324          *  pData is not NULL. When the pData pointer is NULL, the function skips this
1325          *  task. Sets Data ready status: This generates the first DMA transfer and
1326          *  prepares data in endpoint buffer.
1327          *
1328          *  \param epNumber Contains the data endpoint number.
1329          *            Valid values are between 1 and 8.
1330          *  \param *pData A pointer to a data array from which the data for the endpoint space
1331          *          is loaded.
1332          *  \param length The number of bytes to transfer from the array and then send as
1333          *          a result of an IN request. Valid values are between 0 and 512
1334          *          (1023 for DMA with Automatic Buffer Management mode). The value 512
1335          *          is applicable if only one endpoint is used.
1336          *
1337          *
1338          * \reentrant
1339          *  No.
1340          *
1341          *******************************************************************************/
1342          void USBUART_LoadInEP(uint8 epNumber, const uint8 pData[], uint16 length)
1343                                                                                  
1344          {
1345   1          if ((epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 23  

1346   1          {
1347   2          #if (!USBUART_EP_MANAGEMENT_DMA_AUTO)
1348   2              /* Limit length to available buffer USB IP buffer size.*/
1349   2              if (length > (USBUART_EPX_DATA_BUF_MAX - USBUART_EP[epNumber].buffOffset))
1350   2              {
1351   3                  length = USBUART_EPX_DATA_BUF_MAX - USBUART_EP[epNumber].buffOffset;
1352   3              }
1353   2          #endif /* (!USBUART_EP_MANAGEMENT_DMA_AUTO) */
1354   2      
1355   2              /* Set count and data toggle. */
1356   2              USBUART_SIE_EP_BASE.sieEp[epNumber].epCnt0 = (uint8) HI8(length) | USBUART_EP[epNumber].epToggle;
1357   2              USBUART_SIE_EP_BASE.sieEp[epNumber].epCnt1 = (uint8) LO8(length);
1358   2      
1359   2          #if (USBUART_EP_MANAGEMENT_MANUAL)
1360   2              if (NULL != pData)
1361   2              {
1362   3                              /* Copy data using arbiter data register. */
1363   3                  uint16 i;
1364   3                  for (i = 0u; i < length; ++i)
1365   3                  {
1366   4                      USBUART_ARB_EP_BASE.arbEp[epNumber].rwDr = pData[i];
1367   4                  }
1368   3              }
1369   2      
1370   2              /* IN endpoint buffer is full - read to be read. */
1371   2              USBUART_EP[epNumber].apiEpState = USBUART_NO_EVENT_PENDING;
1372   2      
1373   2              /* Arm IN endpoint. */
1374   2              USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBUART_EP[epNumber].epMode;
1375   2      
1376   2          #else
              
                      #if (CY_PSOC3 || CY_PSOC5LP)
                          /* Initialize DMA if it was not initialized. */
                          if (DMA_INVALID_TD == USBUART_DmaTd[epNumber])
                          {
                              USBUART_InitEP_DMA(epNumber, pData);
                          }
                      #endif /* (CY_PSOC3 || CY_PSOC5LP) */
              
                      #if (USBUART_EP_MANAGEMENT_DMA_MANUAL)
                          /* IN endpoint buffer will be fully loaded by DMA shortly. */
                          USBUART_EP[epNumber].apiEpState = USBUART_NO_EVENT_PENDING;
              
                          if ((pData != NULL) && (length > 0u))
                          {
                          #if (CY_PSOC4)
                              uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
                              /* Disable DMA channel: start configuration. */
                              USBUART_CyDmaChDisable(channelNum);
              
                              /* Configure source and destination. */
                              USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR0, (void*) pData);
                              USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) &USBUART_ARB_EP_BASE.ar
             -bEp[epNumber].rwDr);
              
                              /* Configure DMA descriptor. */
                              --length;
                              USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR0, USBUART_DMA_COMMON_CFG | len
             -gth |
                                                                      CYDMA_BYTE | CYDMA_ELEMENT_WORD | CYDMA_INC_SRC_AD
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 24  

             -DR | CYDMA_INVALIDATE | CYDMA_PREEMPTABLE);
              
                              /* Validate descriptor to execute on following DMA request. */
                              USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
              
                              /* Enable DMA channel: configuration complete. */
                              USBUART_CyDmaChEnable(channelNum);
                          #else
                              /* Configure DMA to transfer data. */
                              (void) CyDmaChDisable(USBUART_DmaChan[epNumber]);
                              (void) CyDmaTdSetConfiguration(USBUART_DmaTd[epNumber], length, CY_DMA_DISABLE_TD, TD_TERM
             -IN_EN | TD_INC_SRC_ADR);
                              (void) CyDmaTdSetAddress(USBUART_DmaTd[epNumber], LO16((uint32) pData), LO16((uint32) &USB
             -UART_ARB_EP_BASE.arbEp[epNumber].rwDr));
              
                              /* Enable DMA channel. */
                              (void) CyDmaChSetInitialTd(USBUART_DmaChan[epNumber], USBUART_DmaTd[epNumber]);
                              (void) CyDmaChEnable(USBUART_DmaChan[epNumber], 1u);
                          #endif /* (CY_PSOC4) */
              
                              /* Generate DMA request. */
                              USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg |=  (uint8)  USBUART_ARB_EPX_CFG_DMA_REQ;
                              USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg &=  (uint8) ~USBUART_ARB_EPX_CFG_DMA_REQ;
              
                              /* IN endpoint will be armed in ARB_ISR(source: IN_BUF_FULL) after first DMA transfer has 
             -been completed. */
                          }
                          else
                          {
                              /* When zero-length packet: arm IN endpoint directly. */
                              USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBUART_EP[epNumber].epMode;
                          }
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_MANUAL) */
              
                      #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
                          if (pData != NULL)
                          {
                          #if (CY_PSOC4)
                              uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
                              /* Store address of buffer. */
                              USBUART_DmaEpBufferAddrBackup[epNumber] = (uint32) pData;
              
                              /* Disable DMA channel: start configuration. */
                              USBUART_CyDmaChDisable(channelNum);
              
                              /* Set destination address. */
                              USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) &USBUART_ARB_EP_BASE.ar
             -bEp[epNumber].rwDr);
                              USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR1, (void*) &USBUART_ARB_EP_BASE.ar
             -bEp[epNumber].rwDr);
              
                              /* Configure DMA descriptor. */
                              USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR0, USBUART_DMA_COMMON_CFG  |
                                                                      CYDMA_BYTE | CYDMA_ELEMENT_WORD | CYDMA_INC_SRC_AD
             -DR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                              /* Configure DMA descriptor. */
                              USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR1, USBUART_DMA_COMMON_CFG  |
                                                                      CYDMA_BYTE | CYDMA_ELEMENT_WORD | CYDMA_INC_SRC_AD
             -DR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 25  

                              /* Enable interrupt from DMA channel. */
                              USBUART_CyDmaSetInterruptMask(channelNum);
              
              
                              /* Enable DMA channel: configuration complete. */
                              USBUART_CyDmaChEnable(channelNum);
              
                          #else
                              (void) CyDmaChDisable(USBUART_DmaChan[epNumber]);
              
                              #if (USBUART_EP_DMA_AUTO_OPT == 0u)
                                  USBUART_inLength[epNumber] = length;
                                  USBUART_inDataPointer[epNumber] = pData;
              
                                  /* Configure DMA to send data only for first burst */
                                  (void) CyDmaTdSetConfiguration(USBUART_DmaTd[epNumber],
                                      (length > USBUART_DMA_BYTES_PER_BURST) ? USBUART_DMA_BYTES_PER_BURST : length,
                                      USBUART_DmaNextTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR);
                                  (void) CyDmaTdSetAddress(USBUART_DmaTd[epNumber], LO16((uint32) pData),
                                                                                             LO16((uint32) &USBUART_ARB_
             -EP_BASE.arbEp[epNumber].rwDr));
              
                                  /* The second TD will be executed only when the first one fails.
                                  *  The intention of this TD is to generate NRQ interrupt
                                  *  and repeat 2 last bytes of the first burst.
                                  */
                                  (void) CyDmaTdSetConfiguration(USBUART_DmaNextTd[epNumber], 1u,
                                                                 USBUART_DmaNextTd[epNumber],
                                                                 USBUART_epX_TD_TERMOUT_EN[epNumber]);
              
                                  /* Configure DmaNextTd to clear Data Ready status. */
                                  (void) CyDmaTdSetAddress(USBUART_DmaNextTd[epNumber], LO16((uint32) &clearInDataRdySta
             -tus),
                                                                                                 LO16((uint32) &USBUART_
             -ARB_EP_BASE.arbEp[epNumber].epCfg));
                              #else
                                  /* Configure DMA to send all data. */
                                  (void) CyDmaTdSetConfiguration(USBUART_DmaTd[epNumber], length,
                                                                 USBUART_DmaTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR)
             -;
                                  (void) CyDmaTdSetAddress(USBUART_DmaTd[epNumber], LO16((uint32) pData),
                                                                                             LO16((uint32) &USBUART_ARB_
             -EP_BASE.arbEp[epNumber].rwDr));
                              #endif /* (USBUART_EP_DMA_AUTO_OPT == 0u) */
              
                              /* Clear any potential pending DMA requests before starting DMA channel to transfer data. 
             -*/
                              (void) CyDmaClearPendingDrq(USBUART_DmaChan[epNumber]);
                              /* Enable DMA. */
                              (void) CyDmaChSetInitialTd(USBUART_DmaChan[epNumber], USBUART_DmaTd[epNumber]);
                              (void) CyDmaChEnable(USBUART_DmaChan[epNumber], 1u);
                          #endif /* (CY_PSOC4) */
                          }
                          else
                          {
                              /* IN endpoint buffer (32 bytes) will shortly be preloaded by DMA. */
                              USBUART_EP[epNumber].apiEpState = USBUART_NO_EVENT_PENDING;
              
                              if (length > 0u)
                              {
                              #if (CY_PSOC4)
                                  uint32 lengthDescr0, lengthDescr1;
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 26  

                                  uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
                                  /* Get number of full bursts. */
                                  USBUART_DmaEpBurstCnt[epNumber] = (uint8) (length / USBUART_DMA_BYTES_PER_BURST);
              
                                  /* Get number of elements in the last burst. */
                                  USBUART_DmaEpLastBurstEl[epNumber] = (uint8) (length % USBUART_DMA_BYTES_PER_BURST);
              
                                  /* Get total number of bursts. */
                                  USBUART_DmaEpBurstCnt[epNumber] += (0u != USBUART_DmaEpLastBurstEl[epNumber]) ? 1u : 0
             -u;
              
                                  /* Adjust number of data elements transferred in last burst. */
                                  USBUART_DmaEpLastBurstEl[epNumber] = (0u != USBUART_DmaEpLastBurstEl[epNumber]) ?
                                                                                        (USBUART_DmaEpLastBurstEl[epNumb
             -er] - 1u) :
                                                                                        (USBUART_DMA_BYTES_PER_BURST - 1
             -u);
              
                                  /* Get number of data elements to transfer for descriptor 0 and 1. */
                                  lengthDescr0 = (1u == USBUART_DmaEpBurstCnt[epNumber]) ? USBUART_DmaEpLastBurstEl[epNu
             -mber] : (USBUART_DMA_BYTES_PER_BURST - 1u);
                                  lengthDescr1 = (2u == USBUART_DmaEpBurstCnt[epNumber]) ? USBUART_DmaEpLastBurstEl[epNu
             -mber] : (USBUART_DMA_BYTES_PER_BURST - 1u);
              
              
                                  /* Mark which descriptor is last one to execute. */
                                  USBUART_DmaEpLastBurstEl[epNumber] |= (0u != (USBUART_DmaEpBurstCnt[epNumber] & 0x1u))
             - ?
                                                                                          USBUART_DMA_DESCR0_MASK : USBU
             -ART_DMA_DESCR1_MASK;
              
                                  /* Restore DMA settings for current transfer. */
                                  USBUART_CyDmaChDisable(channelNum);
              
                                  /* Restore destination address for input endpoint. */
                                  USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR0, (void*) ((uint32) USBUART_D
             -maEpBufferAddrBackup[epNumber]));
                                  USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR1, (void*) ((uint32) USBUART_D
             -maEpBufferAddrBackup[epNumber] +
                                                                                                                        
             -         USBUART_DMA_BYTES_PER_BURST));
              
                                  /* Set number of elements to transfer. */
                                  USBUART_CyDmaSetNumDataElements(channelNum, USBUART_DMA_DESCR0, lengthDescr0);
                                  USBUART_CyDmaSetNumDataElements(channelNum, USBUART_DMA_DESCR1, lengthDescr1);
              
                                  /* Validate descriptor 0 and command to start with it. */
                                  USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
                                  USBUART_CyDmaSetDescriptor0Next(channelNum);
              
                                  /* Validate descriptor 1. */
                                  if (USBUART_DmaEpBurstCnt[epNumber] > 1u)
                                  {
                                      USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR1); 
                                  }                   
              
                                  /* Adjust burst counter taking to account: 2 valid descriptors and interrupt trigger a
             -fter valid descriptor were executed. */
                                  USBUART_DmaEpBurstCnt[epNumber] = USBUART_DMA_GET_BURST_CNT(USBUART_DmaEpBurstCnt[epNu
             -mber]);
              
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 27  

                                  /* Enable DMA channel: configuration complete. */
                                  USBUART_CyDmaChEnable(channelNum);
              
                              #elif (USBUART_EP_DMA_AUTO_OPT == 0u)
                                  USBUART_inLength[epNumber]  = length;
                                  USBUART_inBufFull[epNumber] = 0u;
              
                                  (void) CyDmaChDisable(USBUART_DmaChan[epNumber]);
                                  /* Configure DMA to send data only for first burst. */
                                  (void) CyDmaTdSetConfiguration(
                                      USBUART_DmaTd[epNumber], (length > USBUART_DMA_BYTES_PER_BURST) ?
                                      USBUART_DMA_BYTES_PER_BURST : length,
                                      USBUART_DmaNextTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR );
                                  (void) CyDmaTdSetAddress(USBUART_DmaTd[epNumber], LO16((uint32)  USBUART_inDataPointer
             -[epNumber]),
                                                                                             LO16((uint32) &USBUART_ARB_
             -EP_BASE.arbEp[epNumber].rwDr));
                                  /* Clear Any potential pending DMA requests before starting DMA channel to transfer da
             -ta. */
                                  (void) CyDmaClearPendingDrq(USBUART_DmaChan[epNumber]);
                                  /* Enable DMA. */
                                  (void) CyDmaChSetInitialTd(USBUART_DmaChan[epNumber], USBUART_DmaTd[epNumber]);
                                  (void) CyDmaChEnable(USBUART_DmaChan[epNumber], 1u);
                              #endif /* (CY_PSOC4) */
              
                              #if !defined (USBUART_MANUAL_IN_EP_ARM)
                                  /* Set IN data ready to generate DMA request to load data into endpoint buffer. */
                                  USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg |= USBUART_ARB_EPX_CFG_IN_DATA_RDY;
                              #endif  /* (USBUART_MANUAL_IN_EP_ARM) */
              
                                  /* IN endpoint will be armed in ARB_ISR(source: IN_BUF_FULL) after first DMA transfer 
             -has been completed. */
                              }
                              else
                              {
                                  /* When zero-length packet: arm IN endpoint directly. */
                                  USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBUART_EP[epNumber].epMode;
                              }
                          }
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (USBUART_EP_MANAGEMENT_MANUAL) */
1603   2          }
1604   1      }
1605          
1606          
1607          /*******************************************************************************
1608          * Function Name: USBUART_ReadOutEP
1609          ****************************************************************************//**
1610          *
1611          *   This function performs different functionality depending on the Component’s
1612          *   configured Endpoint Buffer Management. This parameter is defined in the
1613          *   Descriptor Root in Component Configure window.
1614          *
1615          *   *Manual (Static/Dynamic Allocation):*
1616          *   This function moves the specified number of bytes from endpoint buffer to
1617          *   system RAM. The number of bytes actually transferred from endpoint buffer to
1618          *   system RAM is the lesser of the actual number of bytes sent by the host or
1619          *   the number of bytes requested by the length parameter.
1620          *
1621          *   *DMA with Manual Buffer Management:*
1622          *   Configure DMA to transfer data from endpoint buffer to system RAM. Generate
1623          *   a DMA request. The firmware must wait until the DMA completes the data
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 28  

1624          *   transfer after calling the USBUART_ReadOutEP() API. For example,
1625          *   by checking EPstate:
1626          *
1627          *   \snippet /USBFS_sut_02.cydsn/main.c checking EPstatey
1628          *
1629          *   The USBFS_EnableOutEP() has to be called to allow host to write data into
1630          *   the endpoint buffer after DMA has completed transfer data from OUT endpoint
1631          *   buffer to SRAM.
1632          *
1633          *   *DMA with Automatic Buffer Management:*
1634          *   Configure DMA. This is required only once and automatically generates DMA
1635          *   requests as data arrives
1636          *
1637          *  \param epNumber: Contains the data endpoint number.
1638          *            Valid values are between 1 and 8.
1639          *  \param pData: A pointer to a data array from which the data for the endpoint
1640          *         space is loaded.
1641          *  \param length: The number of bytes to transfer from the USB Out endpoint and
1642          *          loads it into data array. Valid values are between 0 and 1023. The
1643          *          function moves fewer than the requested number of bytes if the host
1644          *          sends fewer bytes than requested.
1645          *
1646          * \return
1647          *  Number of bytes received, 0 for an invalid endpoint.
1648          *
1649          * \reentrant
1650          *  No.
1651          *
1652          *******************************************************************************/
1653          uint16 USBUART_ReadOutEP(uint8 epNumber, uint8 pData[], uint16 length)
1654                                                                                  
1655          {
1656   1          if ((pData != NULL) && (epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
1657   1          {
1658   2          #if (!USBUART_EP_MANAGEMENT_DMA_AUTO)
1659   2              /* Adjust requested length to available data. */
1660   2              length = (length > USBUART_GetEPCount(epNumber)) ? USBUART_GetEPCount(epNumber) : length;
1661   2          #endif /* (!USBUART_EP_MANAGEMENT_DMA_AUTO) */
1662   2      
1663   2          #if (USBUART_EP_MANAGEMENT_MANUAL)
1664   2              {
1665   3                  /* Copy data using arbiter data register. */
1666   3                  uint16 i;
1667   3                  for (i = 0u; i < length; ++i)
1668   3                  {
1669   4                      pData[i] = (uint8) USBUART_ARB_EP_BASE.arbEp[epNumber].rwDr;
1670   4                  }
1671   3              }
1672   2      
1673   2              /* Arm OUT endpoint after data has been copied from endpoint buffer. */
1674   2              USBUART_EnableOutEP(epNumber);
1675   2          #else
              
                      #if (CY_PSOC3 || CY_PSOC5LP)
                          /* Initialize DMA if it was not initialized. */
                          if (DMA_INVALID_TD == USBUART_DmaTd[epNumber])
                          {
                              USBUART_InitEP_DMA(epNumber, pData);
                          }
                      #endif /* (CY_PSOC3 || CY_PSOC5LP) */
              
                      #if (USBUART_EP_MANAGEMENT_DMA_MANUAL)
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 29  

                      #if (CY_PSOC4)
                      {
                          uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
                          /* Disable DMA channel: start configuration. */
                          USBUART_CyDmaChDisable(channelNum);
              
                          /* Configure source and destination. */
                          USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR0, (void*) &USBUART_ARB_EP_BASE.arbEp[
             -epNumber].rwDr);
                          USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) pData);
              
                          /* Configure DMA descriptor. */
                          USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR0, USBUART_DMA_COMMON_CFG | (uint16
             -)(length - 1u) |
                                                                  CYDMA_BYTE | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_ADDR |
             - CYDMA_INVALIDATE | CYDMA_PREEMPTABLE);
              
                          /* Validate descriptor to execute on following DMA request. */
                          USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
              
                          /* Enable DMA channel: configuration complete. */
                          USBUART_CyDmaChEnable(channelNum);
                      }
                      #else
                          /* Configure DMA to transfer data. */
                          (void) CyDmaChDisable(USBUART_DmaChan[epNumber]);
                          (void) CyDmaTdSetConfiguration(USBUART_DmaTd[epNumber], length, CY_DMA_DISABLE_TD, TD_TERMIN_E
             -N | TD_INC_DST_ADR);
                          (void) CyDmaTdSetAddress(USBUART_DmaTd[epNumber], LO16((uint32) &USBUART_ARB_EP_BASE.arbEp[epN
             -umber].rwDr), LO16((uint32)pData));
              
                          /* Enable DMA channel. */
                          (void) CyDmaChSetInitialTd(USBUART_DmaChan[epNumber], USBUART_DmaTd[epNumber]);
                          (void) CyDmaChEnable(USBUART_DmaChan[epNumber], 1u);
                      #endif /* (CY_PSOC4) */
              
                          /* Generate DMA request. */
                          USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg |=  (uint8)  USBUART_ARB_EPX_CFG_DMA_REQ;
                          USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg &=  (uint8) ~USBUART_ARB_EPX_CFG_DMA_REQ;
              
                          /* OUT endpoint has to be armed again by user when DMA transfers have been completed.
                          * NO_EVENT_PENDING: notifies that data has been copied from endpoint buffer.
                          */
              
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_MANUAL) */
              
                      #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
                      #if (CY_PSOC4)
                      {
                          uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
                          uint32 lengthDescr0, lengthDescr1;
              
                          /* Get number of full bursts. */
                          USBUART_DmaEpBurstCnt[epNumber] = (uint8) (length / USBUART_DMA_BYTES_PER_BURST);
              
                          /* Get number of elements in the last burst. */
                          USBUART_DmaEpLastBurstEl[epNumber] = (uint8) (length % USBUART_DMA_BYTES_PER_BURST);
              
                          /* Get total number of bursts. */
                          USBUART_DmaEpBurstCnt[epNumber] += (0u != USBUART_DmaEpLastBurstEl[epNumber]) ? 1u : 0u;
              
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 30  

                          /* Adjust number of the data elements transfered in last burst. */
                          USBUART_DmaEpLastBurstEl[epNumber] = (0u != USBUART_DmaEpLastBurstEl[epNumber]) ?
                                                                                (USBUART_DmaEpLastBurstEl[epNumber] - 1u
             -) :
                                                                                (USBUART_DMA_BYTES_PER_BURST - 1u);
              
                          /* Get number of data elements to transfer for descriptor 0 and 1. */
                          lengthDescr0 = (1u == USBUART_DmaEpBurstCnt[epNumber]) ? USBUART_DmaEpLastBurstEl[epNumber] : 
             -(USBUART_DMA_BYTES_PER_BURST - 1u);
                          lengthDescr1 = (2u == USBUART_DmaEpBurstCnt[epNumber]) ? USBUART_DmaEpLastBurstEl[epNumber] : 
             -(USBUART_DMA_BYTES_PER_BURST - 1u);
              
                          /* Mark if revert number of data elements in descriptor after transfer completion. */
                          USBUART_DmaEpLastBurstEl[epNumber] |= (USBUART_DmaEpBurstCnt[epNumber] > 2u) ? USBUART_DMA_DES
             -CR_REVERT : 0u;
              
                          /* Mark last descriptor to be executed. */
                          USBUART_DmaEpLastBurstEl[epNumber] |= (0u != (USBUART_DmaEpBurstCnt[epNumber] & 0x1u)) ?
                                                                                  USBUART_DMA_DESCR0_MASK : USBUART_DMA_
             -DESCR1_MASK;
              
                          /* Store address of buffer and burst counter for endpoint. */
                          USBUART_DmaEpBufferAddrBackup[epNumber] = (uint32) pData;
                          USBUART_DmaEpBurstCntBackup[epNumber]   = USBUART_DmaEpBurstCnt[epNumber];
              
                          /* Adjust burst counter taking to account: 2 valid descriptors and interrupt trigger after val
             -id descriptor were executed. */
                          USBUART_DmaEpBurstCnt[epNumber] = USBUART_DMA_GET_BURST_CNT(USBUART_DmaEpBurstCnt[epNumber]);
              
                          /* Disable DMA channel: start configuration. */
                          USBUART_CyDmaChDisable(channelNum);
              
                          /* Set destination address. */
                          USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR0, (void*) &USBUART_ARB_EP_BASE.arbEp[
             -epNumber].rwDr);
                          USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR1, (void*) &USBUART_ARB_EP_BASE.arbEp[
             -epNumber].rwDr);
              
                          USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) ((uint32) pData));
                          USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR1, (void*) ((uint32) pData + USBUART_D
             -MA_BYTES_PER_BURST));
              
                          /* Configure DMA descriptor. */
                          USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR0, USBUART_DMA_COMMON_CFG  | length
             -Descr0 |
                                                                  CYDMA_BYTE | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_ADDR |
             - CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                          /* Configure DMA descriptor. */
                          USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR1, USBUART_DMA_COMMON_CFG  | length
             -Descr1 |
                                                                  CYDMA_BYTE | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_ADDR |
             - CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                          /* Enable interrupt from DMA channel. */
                          USBUART_CyDmaSetInterruptMask(channelNum);
              
                          /* Validate DMA descriptor 0 and 1. */
                          USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
              
                          if (USBUART_DmaEpBurstCntBackup[epNumber] > 1u)
                          {
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 31  

                              USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR1);
                          }
              
                          /* Enable DMA channel: configuration complete. */
                          USBUART_CyDmaChEnable(channelNum);
                      }
                      #else
                          (void) CyDmaChDisable(USBUART_DmaChan[epNumber]);
                          (void) CyDmaTdSetConfiguration(USBUART_DmaTd[epNumber], length,  USBUART_DmaTd[epNumber], TD_T
             -ERMIN_EN | TD_INC_DST_ADR);
                          (void) CyDmaTdSetAddress(USBUART_DmaTd[epNumber], LO16((uint32) &USBUART_ARB_EP_BASE.arbEp[epN
             -umber].rwDr), LO16((uint32) pData));
              
                          /* Clear Any potential pending DMA requests before starting DMA channel to transfer data. */
                          (void) CyDmaClearPendingDrq(USBUART_DmaChan[epNumber]);
              
                          /* Enable DMA channel. */
                          (void) CyDmaChSetInitialTd(USBUART_DmaChan[epNumber], USBUART_DmaTd[epNumber]);
                          (void) CyDmaChEnable(USBUART_DmaChan[epNumber], 1u);
                      #endif /* (CY_PSOC4) */
              
                          /* OUT endpoint has to be armed again by user when DMA transfers have been completed.
                          * NO_EVENT_PENDING: notifies that data has been copied from endpoint buffer.
                          */
              
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (USBUART_EP_MANAGEMENT_MANUAL) */
1817   2          }
1818   1          else
1819   1          {
1820   2              length = 0u;
1821   2          }
1822   1      
1823   1          return (length);
1824   1      }
1825          
1826          
1827          #if (USBUART_16BITS_EP_ACCESS_ENABLE)
              /*******************************************************************************
              * Function Name: USBUART_LoadInEP16
              ****************************************************************************//**
              *
              *  This function performs different functionality depending on the Component’s
              *  configured Endpoint Buffer Management. This parameter is defined in
              *  the Descriptor Root in Component Configure window.
              *
              *  *Manual (Static/Dynamic Allocation):*
              *  This function loads and enables the specified USB data endpoint for an IN
              *  data transfer.
              *
              *  *DMA with Manual Buffer Management:*
              *  Configures DMA for a data transfer from system RAM to endpoint buffer.
              *  Generates request for a transfer.
              *
              *  *DMA with Automatic Buffer Management:*
              *  Configures DMA. This is required only once, so it is done only when parameter
              *  pData is not NULL. When the pData pointer is NULL, the function skips this
              *  task. Sets Data ready status: This generates the first DMA transfer and
              *  prepares data in endpoint buffer.
              *
              *  \param epNumber Contains the data endpoint number.
              *        Valid values are between 1 and 8.
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 32  

              *  \param *pData A pointer to a data array from which the data for the endpoint
              *        space is loaded. It shall be ensured that this pointer address is even
              *        to ensure the 16-bit transfer is aligned to even address. Else, a hard
              *        fault condition can occur.
              *  \param length The number of bytes to transfer from the array and then send as
              *        a result of an IN request. Valid values are between 0 and 512 (1023 for
              *        DMA with Automatic Buffer Management mode). The value 512 is applicable
              *        if only one endpoint is used.
              *
              * \reentrant
              *  No.
              *
              *******************************************************************************/
              void USBUART_LoadInEP16(uint8 epNumber, const uint8 pData[], uint16 length)
              {
                  /* Check array alignment on half-word boundary. */
                  CYASSERT(0u == (((uint32) pData) & 0x01u));
              
                  if ((epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
                  {
                  #if (!USBUART_EP_MANAGEMENT_DMA_AUTO)
                      /* Limit length to available buffer USB IP buffer size. */
                      if (length > (USBUART_EPX_DATA_BUF_MAX - USBUART_EP[epNumber].buffOffset))
                      {
                          length = USBUART_EPX_DATA_BUF_MAX - USBUART_EP[epNumber].buffOffset;
                      }
                  #endif /* (!USBUART_EP_MANAGEMENT_DMA_AUTO) */
              
                      /* Set count and data toggle. */
                      USBUART_SIE_EP_BASE.sieEp[epNumber].epCnt0 = (uint32) HI8(length) | USBUART_EP[epNumber].epToggle;
                      USBUART_SIE_EP_BASE.sieEp[epNumber].epCnt1 = (uint32) LO8(length);
              
                      /* Adjust requested length: 2 bytes are handled at one data register access. */
                      length += (length & 0x01u);
              
                  #if (USBUART_EP_MANAGEMENT_MANUAL)
                      if (NULL != pData)
                      {
                          /* Convert uint8 array to uint16. */
                          const uint16 *dataBuf = (uint16 *) pData;
              
                          /* Copy data using 16-bits arbiter data register. */
                          uint16 i;
                          for (i = 0u; i < (length >> 1u); ++i)
                          {
                              USBUART_ARB_EP16_BASE.arbEp[epNumber].rwDr16 = dataBuf[i];
                          }
                      }
              
                      /* IN endpoint buffer is full - read to be read. */
                      USBUART_EP[epNumber].apiEpState = USBUART_NO_EVENT_PENDING;
              
                      /* Arm IN endpoint. */
                      USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBUART_EP[epNumber].epMode;
              
                  #else
              
                      #if (USBUART_EP_MANAGEMENT_DMA_MANUAL)
                          /* IN endpoint buffer will be fully loaded by DMA shortly. */
                          USBUART_EP[epNumber].apiEpState = USBUART_NO_EVENT_PENDING;
              
                          if ((pData != NULL) && (length > 0u))
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 33  

                          {
                              uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
                              /* Disable DMA channel: start configuration. */
                              USBUART_CyDmaChDisable(channelNum);
              
                              /* Configure source and destination. */
                              USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR0, (void*) pData);
                              USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) &USBUART_ARB_EP16_BASE.
             -arbEp[epNumber].rwDr16);
              
                              /* Configure DMA descriptor. */
                              length = (length >> 1u) - 1u;
                              USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR0, USBUART_DMA_COMMON_CFG | len
             -gth |
                                                                      CYDMA_HALFWORD | CYDMA_ELEMENT_WORD | CYDMA_INC_SR
             -C_ADDR | CYDMA_INVALIDATE | CYDMA_PREEMPTABLE);
              
                              /* Validate descriptor to execute on following DMA request. */
                              USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
              
                              /* Enable DMA channel: configuration complete. */
                              USBUART_CyDmaChEnable(channelNum);
              
                              /* Generate DMA request. */
                              USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg |=  (uint32)  USBUART_ARB_EPX_CFG_DMA_REQ;
                              USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg &=  (uint32) ~USBUART_ARB_EPX_CFG_DMA_REQ;
              
                              /* IN endpoint will be armed in ARB_ISR(source: IN_BUF_FULL) after first DMA transfer has 
             -been completed. */
                          }
                          else
                          {
                              /* When zero-length packet: arm IN endpoint directly. */
                              USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBUART_EP[epNumber].epMode;
                          }
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_MANUAL) */
              
                      #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
                          if (pData != NULL)
                          {
                              uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
                              /* Store address of buffer. */
                              USBUART_DmaEpBufferAddrBackup[epNumber] = (uint32) pData;
              
                              /* Disable DMA channel: start configuration. */
                              USBUART_CyDmaChDisable(channelNum);
              
                              /* Set destination address. */
                              USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) &USBUART_ARB_EP16_BASE.
             -arbEp[epNumber].rwDr16);
                              USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR1, (void*) &USBUART_ARB_EP16_BASE.
             -arbEp[epNumber].rwDr16);
              
                              /* Configure DMA descriptor. */
                              USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR0, USBUART_DMA_COMMON_CFG  |
                                                                      CYDMA_HALFWORD | CYDMA_ELEMENT_WORD | CYDMA_INC_SR
             -C_ADDR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                              /* Configure DMA descriptor. */
                              USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR1, USBUART_DMA_COMMON_CFG  |
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 34  

                                                                      CYDMA_HALFWORD | CYDMA_ELEMENT_WORD | CYDMA_INC_SR
             -C_ADDR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                              /* Enable interrupt from DMA channel. */
                              USBUART_CyDmaSetInterruptMask(channelNum);
              
                              /* Enable DMA channel: configuration complete. */
                              USBUART_CyDmaChEnable(channelNum);
                          }
                          else
                          {
                              /* IN endpoint buffer (32 bytes) will shortly be preloaded by DMA. */
                              USBUART_EP[epNumber].apiEpState = USBUART_NO_EVENT_PENDING;
              
                              if (length > 0u)
                              {
                                  uint32 lengthDescr0, lengthDescr1;
                                  uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
                                  /* Get number of full bursts. */
                                  USBUART_DmaEpBurstCnt[epNumber] = (uint8) (length / USBUART_DMA_BYTES_PER_BURST);
              
                                  /* Get number of elements in the last burst. */
                                  USBUART_DmaEpLastBurstEl[epNumber] = (uint8) (length % USBUART_DMA_BYTES_PER_BURST);
              
                                  /* Get total number of bursts. */
                                  USBUART_DmaEpBurstCnt[epNumber] += (0u != USBUART_DmaEpLastBurstEl[epNumber]) ? 1u : 0
             -u;
              
                                  /* Adjust number of data elements transferred in last burst. */
                                  USBUART_DmaEpLastBurstEl[epNumber] = (0u != USBUART_DmaEpLastBurstEl[epNumber]) ?
                                                                                        ((USBUART_DmaEpLastBurstEl[epNum
             -ber] >> 1u) - 1u) :
                                                                                         (USBUART_DMA_HALFWORDS_PER_BURS
             -T - 1u);
              
                                  /* Get number of data elements to transfer for descriptor 0 and 1. */
                                  lengthDescr0 = (1u == USBUART_DmaEpBurstCnt[epNumber]) ? USBUART_DmaEpLastBurstEl[epNu
             -mber] : (USBUART_DMA_HALFWORDS_PER_BURST - 1u);
                                  lengthDescr1 = (2u == USBUART_DmaEpBurstCnt[epNumber]) ? USBUART_DmaEpLastBurstEl[epNu
             -mber] : (USBUART_DMA_HALFWORDS_PER_BURST - 1u);
              
                                  /* Mark which descriptor is last one to execute. */
                                  USBUART_DmaEpLastBurstEl[epNumber] |= (0u != (USBUART_DmaEpBurstCnt[epNumber] & 0x1u))
             - ?
                                                                                          USBUART_DMA_DESCR0_MASK : USBU
             -ART_DMA_DESCR1_MASK;
              
                                  /* Restore DMA settings for current transfer. */
                                  USBUART_CyDmaChDisable(channelNum);
              
                                  /* Restore destination address for input endpoint. */
                                  USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR0, (void*) ((uint32) USBUART_D
             -maEpBufferAddrBackup[epNumber]));
                                  USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR1, (void*) ((uint32) USBUART_D
             -maEpBufferAddrBackup[epNumber] +
                                                                                                                        
             -         USBUART_DMA_BYTES_PER_BURST));
              
                                  /* Set number of elements to transfer. */
                                  USBUART_CyDmaSetNumDataElements(channelNum, USBUART_DMA_DESCR0, lengthDescr0);
                                  USBUART_CyDmaSetNumDataElements(channelNum, USBUART_DMA_DESCR1, lengthDescr1);
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 35  

              
                                  /* Validate descriptor 0 and command to start with it. */
                                  USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
                                  USBUART_CyDmaSetDescriptor0Next(channelNum);
              
                                  /* Validate descriptor 1. */
                                  if (USBUART_DmaEpBurstCnt[epNumber] > 1u)
                                  {
                                      USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR1);
                                  }
              
                                  /* Adjust burst counter taking to account: 2 valid descriptors and interrupt trigger a
             -fter valid descriptor were executed. */
                                  USBUART_DmaEpBurstCnt[epNumber] = USBUART_DMA_GET_BURST_CNT(USBUART_DmaEpBurstCnt[epNu
             -mber]);
              
                                  /* Enable DMA channel: configuration complete. */
                                  USBUART_CyDmaChEnable(channelNum);
              
                              #if !defined (USBUART_MANUAL_IN_EP_ARM)
                                  /* Set IN data ready to generate DMA request to load data into endpoint buffer. */
                                  USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg |= USBUART_ARB_EPX_CFG_IN_DATA_RDY;
                              #endif  /* (USBUART_MANUAL_IN_EP_ARM) */
              
                                  /* IN endpoint will be armed in ARB_ISR(source: IN_BUF_FULL) after first DMA transfer 
             -has been completed. */
                              }
                              else
                              {
                                  /* When zero-length packet: arm IN endpoint directly. */
                                  USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBUART_EP[epNumber].epMode;
                              }
                          }
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (USBUART_EP_MANAGEMENT_MANUAL) */
                  }
              }
              
              
              /*******************************************************************************
              * Function Name: USBUART_ReadOutEP16
              ****************************************************************************//**
              *
              *   This function performs different functionality depending on the Component’s
              *   configured Endpoint Buffer Management. This parameter is defined in the
              *   Descriptor Root in Component Configure window.
              *
              *   *Manual (Static/Dynamic Allocation):*
              *   This function moves the specified number of bytes from endpoint buffer to
              *   system RAM. The number of bytes actually transferred from endpoint buffer to
              *   system RAM is the lesser of the actual number of bytes sent by the host or
              *   the number of bytes requested by the length parameter.
              *
              *   *DMA with Manual Buffer Management:*
              *   Configure DMA to transfer data from endpoint buffer to system RAM. Generate
              *   a DMA request. The firmware must wait until the DMA completes the data
              *   transfer after calling the USBUART_ReadOutEP() API. For example,
              *   by checking EPstate:
              *
              *   \snippet /USBFS_sut_02.cydsn/main.c checking EPstatey
              *
              *   The USBFS_EnableOutEP() has to be called to allow host to write data into
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 36  

              *   the endpoint buffer after DMA has completed transfer data from OUT endpoint
              *   buffer to SRAM.
              *
              *   *DMA with Automatic Buffer Management:*
              *   Configure DMA. This is required only once and automatically generates DMA
              *   requests as data arrives
              *
              *  \param epNumber: Contains the data endpoint number.
              *         Valid values are between 1 and 8.
              *  \param pData: A pointer to a data array into which the data for the endpoint
              *         space is copied. It shall be ensured that this pointer address is
              *         even to ensure the 16-bit transfer is aligned to even address. Else,
              *         a hard fault condition can occur.
              *  \param length: The number of bytes to transfer from the USB Out endpoint and
              *         loads it into data array. Valid values are between 0 and 1023. The
              *         function moves fewer than the requested number of bytes if the host
              *         sends fewer bytes than requested.
              *
              * \return
              *  Number of bytes received, 0 for an invalid endpoint.
              *
              * \reentrant
              *  No.
              *
              *******************************************************************************/
              uint16 USBUART_ReadOutEP16(uint8 epNumber, uint8 pData[], uint16 length)
              {
                  uint32 adjLength;
              
                  /* Check array alignment on half-word boundary */
                  CYASSERT(0u == (((uint32) pData) & 0x01u));
              
                  if ((pData != NULL) && (epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
                  {
                  #if (!USBUART_EP_MANAGEMENT_DMA_AUTO)
                      /* Adjust requested length to available data. */
                      length = (length > USBUART_GetEPCount(epNumber)) ? USBUART_GetEPCount(epNumber) : length;
                  #endif /* (!USBUART_EP_MANAGEMENT_DMA_AUTO) */
              
                  /* Adjust requested length: 2 bytes are handled at one data register access. */
                  adjLength =  length + ((uint32)length & 1u);
              
                  #if (USBUART_EP_MANAGEMENT_MANUAL)
                      {
                          /* Convert uint8 array to uint16. */
                          uint16 *dataBuf = (uint16 *) pData;
              
                          /* Copy data using 16-bits arbiter data register. */
                          uint16 i;
                          for (i = 0u; i < (adjLength >> 1u); ++i)
                          {
                              dataBuf[i] = (uint16) USBUART_ARB_EP16_BASE.arbEp[epNumber].rwDr16;
                          }
                      }
              
                      /* Arm OUT endpoint after data has been read from endpoint buffer. */
                      USBUART_EnableOutEP(epNumber);
                  #else
              
                      #if (USBUART_EP_MANAGEMENT_DMA_MANUAL)
                      {
                          uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 37  

              
                          /* Disable DMA channel: start configuration. */
                          USBUART_CyDmaChDisable(channelNum);
              
                          /* Configure source and destination. */
                          USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR0, (void*) &USBUART_ARB_EP16_BASE.arbE
             -p[epNumber].rwDr16);
                          USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) pData);
              
                          /* Configure DMA descriptor. */
                          USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR0, USBUART_DMA_COMMON_CFG | (uint16
             -)((adjLength >> 1u) - 1u) |
                                                                  CYDMA_HALFWORD | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_AD
             -DR | CYDMA_INVALIDATE | CYDMA_PREEMPTABLE);
              
                          /* Validate descriptor to execute on following DMA request. */
                          USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
              
                          /* Enable DMA channel: configuration complete. */
                          USBUART_CyDmaChEnable(channelNum);
              
                          /* Generate DMA request. */
                          USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg |=  (uint32)  USBUART_ARB_EPX_CFG_DMA_REQ;
                          USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg &=  (uint32) ~USBUART_ARB_EPX_CFG_DMA_REQ;
              
                          /* OUT endpoint has to be armed again by user when DMA transfers have been completed.
                          * NO_EVENT_PENDING: notifies that data has been copied from endpoint buffer.
                          */
                      }
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_MANUAL) */
              
                      #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
                      {
                          uint32 lengthDescr0, lengthDescr1;
                          uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
                          /* Get number of full bursts. */
                          USBUART_DmaEpBurstCnt[epNumber] = (uint8) (adjLength / USBUART_DMA_BYTES_PER_BURST);
              
                          /* Get number of elements in last burst. */
                          USBUART_DmaEpLastBurstEl[epNumber] = (uint8) (adjLength % USBUART_DMA_BYTES_PER_BURST);
              
                          /* Get total number of bursts. */
                          USBUART_DmaEpBurstCnt[epNumber] += (0u != USBUART_DmaEpLastBurstEl[epNumber]) ? 1u : 0u;
              
                          /* Adjust number of data elements transferred in last burst. */
                          USBUART_DmaEpLastBurstEl[epNumber] = (0u != USBUART_DmaEpLastBurstEl[epNumber]) ?
                                                                                ((USBUART_DmaEpLastBurstEl[epNumber] >> 
             -1u) - 1u) :
                                                                                 (USBUART_DMA_HALFWORDS_PER_BURST - 1u);
              
                          /* Get number of data elements to transfer for descriptor 0 and 1. */
                          lengthDescr0 = (1u == USBUART_DmaEpBurstCnt[epNumber]) ? USBUART_DmaEpLastBurstEl[epNumber] : 
             -(USBUART_DMA_HALFWORDS_PER_BURST - 1u);
                          lengthDescr1 = (2u == USBUART_DmaEpBurstCnt[epNumber]) ? USBUART_DmaEpLastBurstEl[epNumber] : 
             -(USBUART_DMA_HALFWORDS_PER_BURST - 1u);
              
                          /* Mark last descriptor to be executed. */
                          USBUART_DmaEpLastBurstEl[epNumber] |= (0u != (USBUART_DmaEpBurstCnt[epNumber] & 0x1u)) ?
                                                                                  USBUART_DMA_DESCR0_MASK : USBUART_DMA_
             -DESCR1_MASK;
              
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 38  

                          /* Mark if revert number of data elements in descriptor after transfer completion. */
                          USBUART_DmaEpLastBurstEl[epNumber] |= (USBUART_DmaEpBurstCnt[epNumber] > 2u) ? USBUART_DMA_DES
             -CR_REVERT : 0u;
              
                          /* Mark that 16-bits access to data register is performed. */
                          USBUART_DmaEpLastBurstEl[epNumber] |= USBUART_DMA_DESCR_16BITS;
              
                          /* Store address of buffer and burst counter for endpoint. */
                          USBUART_DmaEpBufferAddrBackup[epNumber] = (uint32) pData;
                          USBUART_DmaEpBurstCntBackup[epNumber]   = USBUART_DmaEpBurstCnt[epNumber];
              
                          /* Adjust burst counter taking to account: 2 valid descriptors and interrupt trigger after val
             -id descriptor were executed. */
                          USBUART_DmaEpBurstCnt[epNumber] = USBUART_DMA_GET_BURST_CNT(USBUART_DmaEpBurstCnt[epNumber]);
              
                          /* Disable DMA channel: start configuration. */
                          USBUART_CyDmaChDisable(channelNum);
              
                          /* Set destination address. */
                          USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR0, (void*) &USBUART_ARB_EP16_BASE.arbE
             -p[epNumber].rwDr16);
                          USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR1, (void*) &USBUART_ARB_EP16_BASE.arbE
             -p[epNumber].rwDr16);
              
                          USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) ((uint32) pData));
                          USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR1, (void*) ((uint32) pData + USBUART_D
             -MA_BYTES_PER_BURST));
              
                          /* Configure DMA descriptor 0. */
                          USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR0, USBUART_DMA_COMMON_CFG  | length
             -Descr0 |
                                                                  CYDMA_HALFWORD | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_AD
             -DR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                          /* Configure DMA descriptor 1. */
                          USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR1, USBUART_DMA_COMMON_CFG  | length
             -Descr1 |
                                                                  CYDMA_HALFWORD | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_AD
             -DR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                          /* Enable interrupt from DMA channel. */
                          USBUART_CyDmaSetInterruptMask(channelNum);
              
                          /* Validate DMA descriptor 0 and 1. */
                          USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
                          
                          if (USBUART_DmaEpBurstCntBackup[epNumber] > 1u)
                          {
                              USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR1);
                          }
              
                          /* Enable DMA channel: configuration complete. */
                          USBUART_CyDmaChEnable(channelNum);
              
                          /* OUT endpoint has to be armed again by user when DMA transfers have been completed.
                          * NO_EVENT_PENDING: notifies that data has been copied from endpoint buffer.
                          */
                      }
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (USBUART_EP_MANAGEMENT_MANUAL) */
                  }
                  else
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 39  

                  {
                      length = 0u;
                  }
              
                  return (length);
              }
              #endif /* (USBUART_16BITS_EP_ACCESS_ENABLE) */
2256          
2257          
2258          /*******************************************************************************
2259          * Function Name: USBUART_EnableOutEP
2260          ****************************************************************************//**
2261          *
2262          *  This function enables the specified endpoint for OUT transfers. Do not call
2263          *  this function for IN endpoints.
2264          *
2265          *  \param epNumber: Contains the data endpoint number. Valid values are between
2266          *  1 and 8.
2267          *
2268          * \globalvars
2269          *
2270          *  \ref USBUART_EP[epNumber].apiEpState - set to NO_EVENT_PENDING
2271          *
2272          * \reentrant
2273          *  No.
2274          *
2275          *******************************************************************************/
2276          void USBUART_EnableOutEP(uint8 epNumber) 
2277          {
2278   1          if ((epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
2279   1          {
2280   2              USBUART_EP[epNumber].apiEpState = USBUART_NO_EVENT_PENDING;
2281   2      
2282   2              /* Enable OUT endpoint to be written by Host. */
2283   2              USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBUART_EP[epNumber].epMode;
2284   2              
2285   2          }
2286   1      }
2287          
2288          
2289          /*******************************************************************************
2290          * Function Name: USBUART_DisableOutEP
2291          ****************************************************************************//**
2292          *
2293          *  This function disables the specified USBFS OUT endpoint. Do not call this
2294          *  function for IN endpoints.
2295          *
2296          *  \param epNumber: Contains the data endpoint number.
2297          *            Valid values are between 1 and 8.
2298          *
2299          *******************************************************************************/
2300          void USBUART_DisableOutEP(uint8 epNumber) 
2301          {
2302   1          if ((epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
2303   1          {
2304   2              /* Set NAK response for OUT endpoint. */
2305   2              USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBUART_MODE_NAK_OUT;
2306   2          }
2307   1      }
2308          
2309          
2310          /*******************************************************************************
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 40  

2311          * Function Name: USBUART_Force
2312          ****************************************************************************//**
2313          *
2314          *  This function forces a USB J, K, or SE0 state on the D+/D– lines. It provides
2315          *  the necessary mechanism for a USB device application to perform a USB Remote
2316          *  Wakeup. For more information, see the USB 2.0 Specification for details on
2317          *  Suspend and Resume.
2318          *
2319          *  \param state A byte indicating which of the four bus states to enable.
2320          *        Symbolic names  and their associated values are listed here:
2321          *    State                      |Description
2322          *    ---------------------------|----------------------------------------------
2323          *    USBUART_FORCE_J   | Force a J State onto the D+/D– lines
2324          *    USBUART_FORCE_K   | Force a K State onto the D+/D– lines
2325          *    USBUART_FORCE_SE0 | Force a Single Ended 0 onto the D+/D– lines
2326          *    USBUART_FORCE_NONE| Return bus to SIE control
2327          *
2328          *
2329          *******************************************************************************/
2330          void USBUART_Force(uint8 bState) 
2331          {
2332   1          /* This registers is used only for manual control of SIE (no masking is
2333   1          * needed before write into it).
2334   1          */
2335   1          USBUART_USBIO_CR0_REG = bState;
2336   1      }
2337          
2338          
2339          /*******************************************************************************
2340          * Function Name: USBUART_GetEPAckState
2341          ****************************************************************************//**
2342          *
2343          *  This function determines whether an ACK transaction occurred on this endpoint
2344          *  by reading the ACK bit in the control register of the endpoint. It does not
2345          *  clear the ACK bit.
2346          *
2347          *  \param epNumber Contains the data endpoint number.
2348          *            Valid values are between 1 and 8.
2349          *
2350          *  \return
2351          *  If an ACKed transaction occurred, this function returns a non-zero value.
2352          *  Otherwise, it returns zero.
2353          *
2354          *******************************************************************************/
2355          uint8 USBUART_GetEPAckState(uint8 epNumber) 
2356          {
2357   1          uint8 cr = 0u;
2358   1      
2359   1          if ((epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
2360   1          {
2361   2              cr = USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 & USBUART_MODE_ACKD;
2362   2          }
2363   1      
2364   1          return ((uint8) cr);
2365   1      }
2366          
2367          
2368          /*******************************************************************************
2369          * Function Name: USBUART_SetPowerStatus
2370          ****************************************************************************//**
2371          *
2372          *  This function sets the current power status. The device replies to USB
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 41  

2373          *  GET_STATUS requests based on this value. This allows the device to properly
2374          *  report its status for USB Chapter 9 compliance. Devices can change their
2375          *  power source from self powered to bus powered at any time and report their
2376          *  current power source as part of the device status. You should call this
2377          *  function any time your device changes from self powered to bus powered or
2378          *  vice versa, and set the status appropriately.
2379          *
2380          *  \param powerStatus: Contains the desired power status, one for self powered
2381          *        or zero for bus powered. Symbolic names and their associated values are
2382          *        given here:
2383          *  Power Status                                |Description
2384          *  --------------------------------------------|---------------------------
2385          *  USBUART_DEVICE_STATUS_BUS_POWERED  | Set the device to bus powered
2386          *  USBUART_DEVICE_STATUS_SELF_POWERED | Set the device to self powered
2387          *
2388          * \globalvars
2389          *
2390          *  \ref USBUART_deviceStatus - set power status
2391          *
2392          * \reentrant
2393          *  No.
2394          *
2395          *******************************************************************************/
2396          void USBUART_SetPowerStatus(uint8 powerStatus) 
2397          {
2398   1          if (powerStatus != USBUART_DEVICE_STATUS_BUS_POWERED)
2399   1          {
2400   2              USBUART_deviceStatus |= (uint8)  USBUART_DEVICE_STATUS_SELF_POWERED;
2401   2          }
2402   1          else
2403   1          {
2404   2              USBUART_deviceStatus &= (uint8) ~USBUART_DEVICE_STATUS_SELF_POWERED;
2405   2          }
2406   1      }
2407          
2408          
2409          #if (USBUART_VBUS_MONITORING_ENABLE)
                  /***************************************************************************
                  * Function Name: USBUART_VBusPresent
                  ************************************************************************//**
                  *
                  *  Determines VBUS presence for self-powered devices. This function is
                  *  available when the VBUS Monitoring option is enabled in the Advanced tab.
                  *
                  * \return
                  *  The return value can be the following:
                  *  Return Value | Description
                  *  -------------|-----------------
                  *  1            | VBUS is present
                  *  0            | VBUS is absent
                  *
                  *
                  ***************************************************************************/
                  uint8 USBUART_VBusPresent(void) 
                  {
                      return ((0u != (USBUART_VBUS_STATUS_REG & USBUART_VBUS_VALID)) ? (uint8) 1u : (uint8) 0u);
                  }
              #endif /* (USBUART_VBUS_MONITORING_ENABLE) */
2431          
2432          
2433          /*******************************************************************************
2434          * Function Name: USBUART_RWUEnabled
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 42  

2435          ****************************************************************************//**
2436          *
2437          *  This function returns the current remote wakeup status.
2438          *  If the device supports remote wakeup, the application should use this
2439          *  function to determine if remote wakeup was enabled by the host. When the
2440          *  device is suspended and it determines the conditions to initiate a remote
2441          *  wakeup are met, the application should use the USBFS_Force() function to
2442          *  force the appropriate J and K states onto the USB bus, signaling a remote
2443          *  wakeup.
2444          *
2445          *
2446          * \return
2447          *  Returns non-zero value if remote wakeup is enabled and zero otherwise.
2448          *
2449          * \globalvars
2450          *  USBUART_deviceStatus - checked to determine remote status
2451          *
2452          *******************************************************************************/
2453          uint8 USBUART_RWUEnabled(void) 
2454          {
2455   1          uint8 result = USBUART_FALSE;
2456   1      
2457   1          if (0u != (USBUART_deviceStatus & USBUART_DEVICE_STATUS_REMOTE_WAKEUP))
2458   1          {
2459   2              result = USBUART_TRUE;
2460   2          }
2461   1      
2462   1          return (result);
2463   1      }
2464          
2465          
2466          /*******************************************************************************
2467          * Function Name: USBUART_GetDeviceAddress
2468          ****************************************************************************//**
2469          *
2470          *  This function returns the currently assigned address for the USB device.
2471          *
2472          * \return
2473          *  Returns the currently assigned address.
2474          *  Returns 0 if the device has not yet been assigned an address.
2475          *
2476          *******************************************************************************/
2477          uint8 USBUART_GetDeviceAddress(void) 
2478          {
2479   1          return (uint8)(USBUART_CR0_REG & USBUART_CR0_DEVICE_ADDRESS_MASK);
2480   1      }
2481          
2482          
2483          /*******************************************************************************
2484          * Function Name: USBUART_EnableSofInt
2485          ****************************************************************************//**
2486          *
2487          *  This function enables interrupt generation when a Start-of-Frame (SOF)
2488          *  packet is received from the host.
2489          *
2490          *******************************************************************************/
2491          void USBUART_EnableSofInt(void) 
2492          {
2493   1      #if (CY_PSOC4)
                  /* Enable SOF interrupt interrupt source. */
                  USBUART_INTR_SIE_MASK_REG |= (uint32) USBUART_INTR_SIE_SOF_INTR;
              #else
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 43  

2497   1          /* Enable SOF interrupt if it is present. */
2498   1          #if (USBUART_SOF_ISR_ACTIVE)
2499   1              CyIntEnable(USBUART_SOF_VECT_NUM);
2500   1          #endif /* (USBUART_SOF_ISR_ACTIVE) */
2501   1      #endif /* (CY_PSOC4) */
2502   1      }
2503          
2504          
2505          /*******************************************************************************
2506          * Function Name: USBUART_DisableSofInt
2507          ****************************************************************************//**
2508          *
2509          *  This function disables interrupt generation when a Start-of-Frame (SOF)
2510          *  packet is received from the host.
2511          *
2512          *******************************************************************************/
2513          void USBUART_DisableSofInt(void) 
2514          {
2515   1      #if (CY_PSOC4)
                  /* Disable SOF interrupt interrupt source. */
                  USBUART_INTR_SIE_MASK_REG &= (uint32) ~USBUART_INTR_SIE_SOF_INTR;
              #else
2519   1          /* Disable SOF interrupt if it is present. */
2520   1          #if (USBUART_SOF_ISR_ACTIVE)
2521   1              CyIntDisable(USBUART_SOF_VECT_NUM);
2522   1          #endif /* (USBUART_SOF_ISR_ACTIVE) */
2523   1      #endif /* (CY_PSOC4) */
2524   1      }
2525          
2526          
2527          #if (USBUART_BATT_CHARG_DET_ENABLE)
                  /***************************************************************************
                  * Function Name: USBUART_DetectPortType
                  ************************************************************************//**
                  *
                  *   This function implements the USB  Battery Charger Detection (BCD)
                  *   algorithm to determine the type of USB host downstream port. This API
                  *   is available only for PSoC 4 devices, and should be called when the VBUS
                  *   voltage transition (OFF to ON) is detected on the bus. If the USB device
                  *   functionality is enabled, this API first calls USBFS_Stop() API
                  *   internally to disable the USB device functionality, and then proceeds to
                  *   implement the BCD algorithm to detect the USB host port type.
                  *   The USBFS_Start() API should be called after this API if the USB
                  *   communication needs to be initiated with the host.
                  *   *Note* This API is generated only if the “Enable Battery Charging 
                  *   Detection” option is enabled in the “Advanced” tab of the component GUI.
                  *   *Note* API implements the steps 2-4 of the BCD algorithm which are 
                  *   - Data Contact Detect
                  *   - Primary Detection 
                  *   - Secondary Detection 
                  * 
                  *   The first step of BCD algorithm, namely, VBUS detection shall be handled 
                  *   at the application firmware level.
                  *
                  * \return
                  *   The return value can be the following:
                  *   Return Value                      |Description
                  *   ----------------------------------|-------------------------------------
                  *   USBUART_BCD_PORT_SDP     | Standard downstream port detected
                  *   USBUART_BCD_PORT_CDP     | Charging downstream port detected
                  *   USBUART_BCD_PORT_DCP     | Dedicated charging port detected
                  *   USBUART_BCD_PORT_UNKNOWN | Unable to detect charging port type (proprietary charger type)
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 44  

                  *   USBUART_BCD_PORT_ERR     | Error condition in detection process
                  *
                  *
                  * \sideeffects
                  *
                  *  USB device functionality is disabled by this API if not already disabled.
                  *
                  ***************************************************************************/
                  uint8 USBUART_Bcd_DetectPortType(void)
                  {
                      uint32 bkPwrCtrl;
                      uint32 cr1RegVal;
                      uint32 secondaryDetection = 0u;
                      uint8 result = USBUART_BCD_PORT_UNKNOWN;
              
                      /*Check USB Started and Stop it*/
                      if(0u != USBUART_initVar)
                      {
                          USBUART_Stop();
                      }
                      /*Initialize USBFS IP for Charger detection*/
              
                      /*Enable clock to USB IP. */
                      USBUART_USB_CLK_EN_REG = USBUART_USB_CLK_CSR_CLK_EN;
              
                      /* Enable USBIO control on drive mode of D+ and D- pins. */
                      USBUART_USBIO_CR1_REG &= ~ (uint32) USBUART_USBIO_CR1_IOMODE;
              
                      /* Select VBUS detection source and clear PHY isolate. The application
                      *  level must ensure that VBUS is valid. There is no need to wait 2us
                      *  before VBUS is valid.
                      */
                      bkPwrCtrl = USBUART_POWER_CTRL_REG;
                      USBUART_POWER_CTRL_REG = USBUART_DEFAULT_POWER_CTRL_VBUS\
                                          & (~USBUART_POWER_CTRL_ENABLE_VBUS_PULLDOWN)\
                                          & (~USBUART_POWER_CTRL_ENABLE_DM_PULLDOWN);
              
              
                      /* Enable PHY detector and single-ended and differential receivers.
                       * Enable charger detection.  */
                      USBUART_POWER_CTRL_REG |= USBUART_DEFAULT_POWER_CTRL_PHY\
                                                       | USBUART_POWER_CTRL_ENABLE_CHGDET;
              
                      /* Suspend clear sequence. */
                      USBUART_POWER_CTRL_REG &= (uint32) ~USBUART_POWER_CTRL_SUSPEND;
                      CyDelayUs(USBUART_WAIT_SUSPEND_DEL_DISABLE);
                      USBUART_POWER_CTRL_REG &= (uint32) ~USBUART_POWER_CTRL_SUSPEND_DEL;
              
                      /* Data connection detection
                      * Realization with delay as Hard IP does not support DCD 300 ms.
                      */
                      #if defined (USBUART_NO_DCD)
                      CyDelay(USBUART_BCD_TIMEOUT);
                      #else
                      /* DCD implementation:*/
              
                      {
                          uint16 timeout = USBUART_BCD_TIMEOUT;
                          uint8 connectionApproved = 0u;
                          uint8 connected = 0u;
              
                          /*   BCD spec 1.2: Turns on Idp_src and D- pull-down resistor */
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 45  

                          USBUART_POWER_CTRL_REG |= USBUART_POWER_CTRL_ENABLE_DM_PULLDOWN;
                          USBUART_CHGDET_CTRL_REG |= USBUART_CHGDET_CTRL_DCD_SRC_EN;
              
                          /* BCD spec 1.2: Waits for D+ to be low for a time of Tdcd_dbnc*/
                          while ((0u != timeout) && (0u == connectionApproved))
                          {
                              if (0u == (USBUART_USBIO_CR1_REG & USBUART_USBIO_CR1_DP0))
                              {
                                  connected++;
                              }
                              else
                              {
                                  connected = 0u;
                              }
                              connectionApproved = (USBUART_BCD_TDCD_DBNC < connected) ? 1u:0u;
                              CyDelay(1u);
                              timeout--;
                          }
              
                          /*   BCD spec 1.2: Turns off Idp_src. */
                          USBUART_CHGDET_CTRL_REG &= ~USBUART_CHGDET_CTRL_DCD_SRC_EN;
                      }
                      #endif /*(USBUART_NO_DCD)*/
              
                      /* Primary detection: enable VDP_SRC on D+ and IDM_SINK on D-. */
                      USBUART_CHGDET_CTRL_REG = USBUART_CHGDET_CTRL_PRIMARY;
                      CyDelay(USBUART_BCD_PRIMARY_WAIT);
                      cr1RegVal = USBUART_USBIO_CR1_REG;
              
                      /* Check is it SDP or DCP/CDP, read comparator 2 output. */
                      if (0u == (USBUART_CHGDET_CTRL_REG & USBUART_CHGDET_CTRL_COMP_OUT))
                      {
                          /* Check status of D- line. */
                          if (0u == (cr1RegVal & USBUART_USBIO_CR1_DM0))
                          {
                              result = USBUART_BCD_PORT_SDP;
                          }
                          else
                          {
                              /* ERROR: such combination is impossible. Abort charger
                               * detection.
                              */
                              result = USBUART_BCD_PORT_ERR;
                          }
                      }
                      else
                      {
                              /* Need Secondary detection. Charging port: DCP or proprietary*/
                              secondaryDetection = 1u;
                      }
              
                      /* Secondary detection: Set CHGDET_CTRL register to enable VDM_SRC on D- and IDP_SINK on D+. */
              
                      if (0u != secondaryDetection)
                      {
                          USBUART_CHGDET_CTRL_REG = USBUART_CHGDET_CTRL_DEFAULT \
                                                              | USBUART_CHGDET_CTRL_SECONDARY;
                          CyDelay(USBUART_BCD_SECONDARY_WAIT);
                          cr1RegVal = USBUART_USBIO_CR1_REG;
              
                          /* Check is it SDP or DCP/CDP, read comparator 1 output. */
                          if (0u == (USBUART_CHGDET_CTRL_REG & USBUART_CHGDET_CTRL_COMP_OUT))
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 46  

                          {
                              /* Check status of D+ line. */
                              if (0u == (cr1RegVal & USBUART_USBIO_CR1_DP0))
                              {
                                  result = USBUART_BCD_PORT_CDP;
                              }
                              else
                              {
                                  /* ERROR: such combination is impossible. Abort charger
                                   * detection.
                                  */
                                  result = USBUART_BCD_PORT_ERR;
                              }
                          }
                          else
                          {
                              /* Check status of D+ line. */
                              if (0u == (cr1RegVal & USBUART_USBIO_CR1_DP0))
                              {
                                  result = USBUART_BCD_PORT_DCP;
                              }
                              else
                              {
                                  /* It is may be proprietary charger. Proprietary charge is
                                   * not supported byHardware IP block.
                                  */
                                  result = USBUART_BCD_PORT_UNKNOWN;
                              }
                          }
                      }
              
                      /* Restore CHGDET_CTRL. */
                      USBUART_CHGDET_CTRL_REG = 0u;
              
                      /*Revert registers back*/
                      USBUART_POWER_CTRL_REG = bkPwrCtrl;
                      USBUART_USBIO_CR1_REG |= (uint32) USBUART_USBIO_CR1_IOMODE;
                      USBUART_USB_CLK_EN_REG = ~USBUART_USB_CLK_CSR_CLK_EN;
              
                      return (result);
                  }
              #endif  /* (USBUART_BATT_CHARG_DET_ENABLE) */
2725          
2726          
2727          #if (USBUART_LPM_ACTIVE)
                  /***************************************************************************
                  * Function Name: USBUART_Lpm_GetBeslValue
                  ************************************************************************//**
                  *
                  *  This function returns the Best Effort Service Latency (BESL) value
                  *  sent by the host as part of the LPM token transaction.
                  *
                  * \return
                  *  4-bit BESL value received in the LPM token packet from the host
                  *
                  *
                  ***************************************************************************/
                  uint32 USBUART_Lpm_GetBeslValue(void)
                  {
                      return (uint32) (USBUART_LPM_STAT_REG & USBUART_LPM_STAT_LPM_BESL_MASK);
                  }
              
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 47  

              
                  /***************************************************************************
                  * Function Name: USBUART_Lpm_RemoteWakeUpAllowed
                  ************************************************************************//**
                  *
                  *  This function returns the remote wakeup permission set for the device by
                  *  the host as part of the LPM token transaction.
                  *
                  * \return
                  *   0 - remote wakeup not allowed, 1 - remote wakeup allowed
                  *
                  *
                  ***************************************************************************/
                  uint32 USBUART_Lpm_RemoteWakeUpAllowed(void)
                  {
                      return (uint32) (USBUART_LPM_STAT_REG & USBUART_LPM_STAT_LPM_REMOTE_WAKE);
                  }
              
              
                  /***************************************************************************
                  * Function Name: USBUART_Lpm_SetResponse
                  ************************************************************************//**
                  *
                  *  This function configures the response in the handshake packet the device
                  *  has to send when an LPM token packet is received.
                  *
                  * \param response
                  *   type of response to return for an LPM token packet
                  *   Allowed response values:
                  *       - USBUART_LPM_REQ_ACK - next LPM request will be
                  *                                           responded with ACK
                  *       - USBUART_LPM_REQ_NACK - next LPM request will be
                  *                                           responded with NACK
                  *       - USBUART_LPM_REQ_NYET - next LPM request will be
                  *                                           responded with NYET
                  *
                  ***************************************************************************/
                  void USBUART_Lpm_SetResponse(uint32 response)
                  {
                      uint32 lpmCtrl = USBUART_LPM_CTRL_REG & (uint32) ~USBUART_LPM_CTRL_ACK_NYET_MASK;
              
                      USBUART_LPM_CTRL_REG = lpmCtrl | ((uint32) response & USBUART_LPM_CTRL_ACK_NYET_MASK);
                  }
              
              
                  /***************************************************************************
                  * Function Name: USBUART_Lpm_GetResponse
                  ************************************************************************//**
                  *
                  *  This function returns the currently configured response value that the
                  *  device will send as part of the handshake packet when an LPM token
                  *  packet is received.
                  *
                  * \return
                  *   type of handshake response that will be returned by the device
                  *   for an LPM token packet
                  *   Possible response values:
                  *       - USBUART_LPM_REQ_ACK - next LPM request will be responded
                  *                                        with ACK
                  *       - USBUART_LPM_REQ_NACK - next LPM request will be responded
                  *                                        with NACK
                  *       - USBUART_LPM_REQ_NYET - next LPM request will be responded
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 48  

                  *                                        with NYET
                  *
                  ***************************************************************************/
                  uint32 USBUART_Lpm_GetResponse(void)
                  {
              
                      return  ((uint32) USBUART_LPM_CTRL_REG & (uint32)USBUART_LPM_CTRL_ACK_NYET_MASK);
                  }
              
              
              #endif /* (USBUART_LPM_ACTIVE) */
2818          
2819          
2820          /* [] END OF FILE */
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 49  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _USBUART_Start (BEGIN)
                                           ; SOURCE LINE # 186
0000 900000      R     MOV     DPTR,#device
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#mode
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 187
                                           ; SOURCE LINE # 188
000A 900000      R     MOV     DPTR,#USBUART_initVar
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 189
                                           ; SOURCE LINE # 190
0012 120000      R     LCALL   USBUART_Init
                                           ; SOURCE LINE # 191
0015 900000      R     MOV     DPTR,#USBUART_initVar
0018 7401              MOV     A,#01H
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 192
001B         ?C0001:
                                           ; SOURCE LINE # 194
001B 900000      R     MOV     DPTR,#device
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 900000      R     MOV     DPTR,#mode
0023 E0                MOVX    A,@DPTR
0024 FD                MOV     R5,A
0025 120000      R     LCALL   _USBUART_InitComponent
                                           ; SOURCE LINE # 195
0028 22                RET     
             ; FUNCTION _USBUART_Start (END)

             ; FUNCTION USBUART_Init (BEGIN)
                                           ; SOURCE LINE # 211
                                           ; SOURCE LINE # 212
                                           ; SOURCE LINE # 250
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 257
0008 9043A5            MOV     DPTR,#043A5H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 259
0013 9043B5            MOV     DPTR,#043B5H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 4401              ORL     A,#01H
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 50  

001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 262
001E 90609D            MOV     DPTR,#0609DH
0021 7401              MOV     A,#01H
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 264
0024 906009            MOV     DPTR,#06009H
0027 7402              MOV     A,#02H
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 268
002A 906010            MOV     DPTR,#06010H
002D E0                MOVX    A,@DPTR
002E FF                MOV     R7,A
002F EF                MOV     A,R7
0030 547F              ANL     A,#07FH
0032 FF                MOV     R7,A
0033 EF                MOV     A,R7
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 269
0035 7F00              MOV     R7,#00H
0037 7E00              MOV     R6,#00H
0039 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 274
003C 904394            MOV     DPTR,#04394H
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 EF                MOV     A,R7
0042 54F9              ANL     A,#0F9H
0044 FF                MOV     R7,A
0045 EF                MOV     A,R7
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 278
0047 906012            MOV     DPTR,#06012H
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
004C EF                MOV     A,R7
004D 54DF              ANL     A,#0DFH
004F FF                MOV     R7,A
0050 EF                MOV     A,R7
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 281
0052 904394            MOV     DPTR,#04394H
0055 E0                MOVX    A,@DPTR
0056 FF                MOV     R7,A
0057 EF                MOV     A,R7
0058 4401              ORL     A,#01H
005A FF                MOV     R7,A
005B EF                MOV     A,R7
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 283
005D 7F01              MOV     R7,#01H
005F 7E00              MOV     R6,#00H
0061 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 285
0064 7F28              MOV     R7,#028H
0066 7E00              MOV     R6,#00H
0068 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 287
006B 9051F8            MOV     DPTR,#051F8H
006E E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 51  

006F FF                MOV     R7,A
0070 EF                MOV     A,R7
0071 547F              ANL     A,#07FH
0073 FF                MOV     R7,A
0074 EF                MOV     A,R7
0075 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 288
0076 9051F8            MOV     DPTR,#051F8H
0079 E0                MOVX    A,@DPTR
007A FF                MOV     R7,A
007B EF                MOV     A,R7
007C 54BF              ANL     A,#0BFH
007E FF                MOV     R7,A
007F EF                MOV     A,R7
0080 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 291
0081 904394            MOV     DPTR,#04394H
0084 E0                MOVX    A,@DPTR
0085 FF                MOV     R7,A
0086 EF                MOV     A,R7
0087 4402              ORL     A,#02H
0089 FF                MOV     R7,A
008A EF                MOV     A,R7
008B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 292
008C 7F02              MOV     R7,#02H
008E 7E00              MOV     R6,#00H
0090 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 294
0093 904394            MOV     DPTR,#04394H
0096 E0                MOVX    A,@DPTR
0097 FF                MOV     R7,A
0098 EF                MOV     A,R7
0099 4404              ORL     A,#04H
009B FF                MOV     R7,A
009C EF                MOV     A,R7
009D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 297
009E 906084            MOV     DPTR,#06084H
00A1 E4                CLR     A
00A2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 298
00A3 906085            MOV     DPTR,#06085H
00A6 E4                CLR     A
00A7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 312
00A8 900000      R     MOV     DPTR,#enableInterrupts
00AB E0                MOVX    A,@DPTR
00AC FF                MOV     R7,A
00AD 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 331
00B0 7D07              MOV     R5,#07H
00B2 7F17              MOV     R7,#017H
00B4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 332
00B7 7C00        E     MOV     R4,#HIGH USBUART_BUS_RESET_ISR
00B9 7D00        E     MOV     R5,#LOW USBUART_BUS_RESET_ISR
00BB 7F17              MOV     R7,#017H
00BD 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 335
00C0 7D07              MOV     R5,#07H
00C2 7F18              MOV     R7,#018H
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 52  

00C4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 336
00C7 7C00        E     MOV     R4,#HIGH USBUART_EP_0_ISR
00C9 7D00        E     MOV     R5,#LOW USBUART_EP_0_ISR
00CB 7F18              MOV     R7,#018H
00CD 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 340
00D0 7D07              MOV     R5,#07H
00D2 7F15              MOV     R7,#015H
00D4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 341
00D7 7C00        E     MOV     R4,#HIGH USBUART_SOF_ISR
00D9 7D00        E     MOV     R5,#LOW USBUART_SOF_ISR
00DB 7F15              MOV     R7,#015H
00DD 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 346
00E0 7D07              MOV     R5,#07H
00E2 7F00              MOV     R7,#00H
00E4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 347
00E7 7C00        E     MOV     R4,#HIGH USBUART_EP_1_ISR
00E9 7D00        E     MOV     R5,#LOW USBUART_EP_1_ISR
00EB 7F00              MOV     R7,#00H
00ED 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 352
00F0 7D07              MOV     R5,#07H
00F2 7F01              MOV     R7,#01H
00F4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 353
00F7 7C00        E     MOV     R4,#HIGH USBUART_EP_2_ISR
00F9 7D00        E     MOV     R5,#LOW USBUART_EP_2_ISR
00FB 7F01              MOV     R7,#01H
00FD 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 358
0100 7D07              MOV     R5,#07H
0102 7F02              MOV     R7,#02H
0104 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 359
0107 7C00        E     MOV     R4,#HIGH USBUART_EP_3_ISR
0109 7D00        E     MOV     R5,#LOW USBUART_EP_3_ISR
010B 7F02              MOV     R7,#02H
010D 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 401
0110 7D07              MOV     R5,#07H
0112 7F0C              MOV     R7,#0CH
0114 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 402
0117 7C00        E     MOV     R4,#HIGH USBUART_DP_ISR
0119 7D00        E     MOV     R5,#LOW USBUART_DP_ISR
011B 7F0C              MOV     R7,#0CH
011D 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 409
0120 22                RET     
             ; FUNCTION USBUART_Init (END)

             ; FUNCTION _USBUART_InitComponent (BEGIN)
                                           ; SOURCE LINE # 460
0000 900000      R     MOV     DPTR,#device
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#mode
0008 ED                MOV     A,R5
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 53  

0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 461
                                           ; SOURCE LINE # 469
000A 900000      R     MOV     DPTR,#i
000D E4                CLR     A
000E F0                MOVX    @DPTR,A
000F         ?C0004:
000F 900000      R     MOV     DPTR,#i
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 EF                MOV     A,R7
0015 C3                CLR     C
0016 9402              SUBB    A,#02H
0018 501A              JNC     ?C0005
                                           ; SOURCE LINE # 470
                                           ; SOURCE LINE # 471
001A 900000      R     MOV     DPTR,#i
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
001F 7400        E     MOV     A,#LOW USBUART_hidProtocol
0021 2F                ADD     A,R7
0022 F582              MOV     DPL,A
0024 E4                CLR     A
0025 3400        E     ADDC    A,#HIGH USBUART_hidProtocol
0027 F583              MOV     DPH,A
0029 7401              MOV     A,#01H
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 472
002C 900000      R     MOV     DPTR,#i
002F E0                MOVX    A,@DPTR
0030 04                INC     A
0031 F0                MOVX    @DPTR,A
0032 80DB              SJMP    ?C0004
0034         ?C0005:
                                           ; SOURCE LINE # 476
0034 900000      R     MOV     DPTR,#device
0037 E0                MOVX    A,@DPTR
0038 FF                MOV     R7,A
0039 900000      E     MOV     DPTR,#USBUART_device
003C EF                MOV     A,R7
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 479
003E 900000      E     MOV     DPTR,#USBUART_transferState
0041 E4                CLR     A
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 480
0043 900000      E     MOV     DPTR,#USBUART_configurationChanged
0046 E4                CLR     A
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 481
0048 900000      E     MOV     DPTR,#USBUART_configuration
004B E4                CLR     A
004C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 482
004D 900000      E     MOV     DPTR,#USBUART_interfaceNumber
0050 E4                CLR     A
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 483
0052 900000      E     MOV     DPTR,#USBUART_deviceAddress
0055 E4                CLR     A
0056 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 484
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 54  

0057 900000      E     MOV     DPTR,#USBUART_deviceStatus
005A E4                CLR     A
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 485
005C 900000      E     MOV     DPTR,#USBUART_lastPacketSize
005F E4                CLR     A
0060 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 493
0061 9044C2            MOV     DPTR,#044C2H
0064 7480              MOV     A,#080H
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 494
0067 9044C3            MOV     DPTR,#044C3H
006A 7401              MOV     A,#01H
006C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 497
006D 9044C2            MOV     DPTR,#044C2H
0070 7420              MOV     A,#020H
0072 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 501
0073 9044C0            MOV     DPTR,#044C0H
0076 7401              MOV     A,#01H
0078 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 505
0079 9044C0            MOV     DPTR,#044C0H
007C 7402              MOV     A,#02H
007E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 509
007F 9044C0            MOV     DPTR,#044C0H
0082 7404              MOV     A,#04H
0084 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 573
0085 900000      R     MOV     DPTR,#mode
0088 E0                MOVX    A,@DPTR
0089 FF                MOV     R7,A
008A EF                MOV     A,R7
008B 120000      E     LCALL   ?C?CCASE
008E 0000        R     DW      ?C0008
0090 00                DB      00H
0091 0000        R     DW      ?C0009
0093 01                DB      01H
0094 0000              DW      00H
0096 0000        R     DW      ?C0010
                                           ; SOURCE LINE # 574
                                           ; SOURCE LINE # 575
0098         ?C0008:
                                           ; SOURCE LINE # 577
0098 906009            MOV     DPTR,#06009H
009B E0                MOVX    A,@DPTR
009C FF                MOV     R7,A
009D EF                MOV     A,R7
009E 54FE              ANL     A,#0FEH
00A0 FF                MOV     R7,A
00A1 EF                MOV     A,R7
00A2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 578
00A3 8018              SJMP    ?C0007
                                           ; SOURCE LINE # 580
00A5         ?C0009:
                                           ; SOURCE LINE # 582
00A5 906009            MOV     DPTR,#06009H
00A8 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 55  

00A9 FF                MOV     R7,A
00AA EF                MOV     A,R7
00AB 4401              ORL     A,#01H
00AD FF                MOV     R7,A
00AE EF                MOV     A,R7
00AF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 583
00B0 800B              SJMP    ?C0007
                                           ; SOURCE LINE # 585
00B2         ?C0010:
                                           ; SOURCE LINE # 591
00B2 906009            MOV     DPTR,#06009H
00B5 E0                MOVX    A,@DPTR
00B6 FF                MOV     R7,A
00B7 EF                MOV     A,R7
00B8 4401              ORL     A,#01H
00BA FF                MOV     R7,A
00BB EF                MOV     A,R7
00BC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 593
                                           ; SOURCE LINE # 594
00BD         ?C0007:
                                           ; SOURCE LINE # 627
00BD 906028            MOV     DPTR,#06028H
00C0 7403              MOV     A,#03H
00C2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 630
00C3 906008            MOV     DPTR,#06008H
00C6 7480              MOV     A,#080H
00C8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 631
00C9 7F01              MOV     R7,#01H
00CB 7E00              MOV     R6,#00H
00CD 7D00              MOV     R5,#00H
00CF 7C00              MOV     R4,#00H
00D1 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 635
00D4 906012            MOV     DPTR,#06012H
00D7 7404              MOV     A,#04H
00D9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 636
00DA 22                RET     
             ; FUNCTION _USBUART_InitComponent (END)

             ; FUNCTION USBUART_ReInitComponent (BEGIN)
                                           ; SOURCE LINE # 671
                                           ; SOURCE LINE # 672
                                           ; SOURCE LINE # 679
0000 900000      R     MOV     DPTR,#i
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
0005         ?C0012:
0005 900000      R     MOV     DPTR,#i
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B C3                CLR     C
000C 9402              SUBB    A,#02H
000E 501A              JNC     ?C0013
                                           ; SOURCE LINE # 680
                                           ; SOURCE LINE # 681
0010 900000      R     MOV     DPTR,#i
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 56  

0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 7400        E     MOV     A,#LOW USBUART_hidProtocol
0017 2F                ADD     A,R7
0018 F582              MOV     DPL,A
001A E4                CLR     A
001B 3400        E     ADDC    A,#HIGH USBUART_hidProtocol
001D F583              MOV     DPH,A
001F 7401              MOV     A,#01H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 682
0022 900000      R     MOV     DPTR,#i
0025 E0                MOVX    A,@DPTR
0026 04                INC     A
0027 F0                MOVX    @DPTR,A
0028 80DB              SJMP    ?C0012
002A         ?C0013:
                                           ; SOURCE LINE # 686
002A 900000      E     MOV     DPTR,#USBUART_transferState
002D E4                CLR     A
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 687
002F 900000      E     MOV     DPTR,#USBUART_configurationChanged
0032 E4                CLR     A
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 688
0034 900000      E     MOV     DPTR,#USBUART_configuration
0037 E4                CLR     A
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 689
0039 900000      E     MOV     DPTR,#USBUART_interfaceNumber
003C E4                CLR     A
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 690
003E 900000      E     MOV     DPTR,#USBUART_deviceAddress
0041 E4                CLR     A
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 691
0043 900000      E     MOV     DPTR,#USBUART_deviceStatus
0046 E4                CLR     A
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 692
0048 900000      E     MOV     DPTR,#USBUART_lastPacketSize
004B E4                CLR     A
004C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 699
004D 906028            MOV     DPTR,#06028H
0050 7403              MOV     A,#03H
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 703
0053 906008            MOV     DPTR,#06008H
0056 7480              MOV     A,#080H
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 704
0059 22                RET     
             ; FUNCTION USBUART_ReInitComponent (END)

             ; FUNCTION USBUART_Stop (BEGIN)
                                           ; SOURCE LINE # 729
                                           ; SOURCE LINE # 730
                                           ; SOURCE LINE # 738
0000 120000      E     LCALL   CyEnterCriticalSection
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 57  

0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 741
0008 906008            MOV     DPTR,#06008H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 547F              ANL     A,#07FH
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 744
0013 906012            MOV     DPTR,#06012H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FB              ANL     A,#0FBH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 751
001E 9043A5            MOV     DPTR,#043A5H
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 EF                MOV     A,R7
0024 54FE              ANL     A,#0FEH
0026 FF                MOV     R7,A
0027 EF                MOV     A,R7
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 752
0029 9043B5            MOV     DPTR,#043B5H
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E EF                MOV     A,R7
002F 54FE              ANL     A,#0FEH
0031 FF                MOV     R7,A
0032 EF                MOV     A,R7
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 756
0034 9051F8            MOV     DPTR,#051F8H
0037 E0                MOVX    A,@DPTR
0038 FF                MOV     R7,A
0039 EF                MOV     A,R7
003A 4480              ORL     A,#080H
003C FF                MOV     R7,A
003D EF                MOV     A,R7
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 757
003F 9051F8            MOV     DPTR,#051F8H
0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 EF                MOV     A,R7
0045 4440              ORL     A,#040H
0047 FF                MOV     R7,A
0048 EF                MOV     A,R7
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 761
004A 900000      R     MOV     DPTR,#enableInterrupts
004D E0                MOVX    A,@DPTR
004E FF                MOV     R7,A
004F 120000      E     LCALL   _CyExitCriticalSection
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 58  

                                           ; SOURCE LINE # 770
0052 9044CA            MOV     DPTR,#044CAH
0055 7480              MOV     A,#080H
0057 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 771
0058 9044CB            MOV     DPTR,#044CBH
005B 7401              MOV     A,#01H
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 774
005E 9044CA            MOV     DPTR,#044CAH
0061 7420              MOV     A,#020H
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 778
0064 9044C8            MOV     DPTR,#044C8H
0067 7401              MOV     A,#01H
0069 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 782
006A 9044C8            MOV     DPTR,#044C8H
006D 7402              MOV     A,#02H
006F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 786
0070 9044C8            MOV     DPTR,#044C8H
0073 7404              MOV     A,#04H
0075 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 811
0076 120000      E     LCALL   USBUART_Dp_ClearInterrupt
                                           ; SOURCE LINE # 812
0079 9044D9            MOV     DPTR,#044D9H
007C 7410              MOV     A,#010H
007E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 818
007F 900000      E     MOV     DPTR,#USBUART_configurationChanged
0082 E4                CLR     A
0083 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 819
0084 900000      E     MOV     DPTR,#USBUART_configuration
0087 E4                CLR     A
0088 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 820
0089 900000      E     MOV     DPTR,#USBUART_interfaceNumber
008C E4                CLR     A
008D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 821
008E 900000      E     MOV     DPTR,#USBUART_deviceAddress
0091 E4                CLR     A
0092 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 822
0093 900000      E     MOV     DPTR,#USBUART_deviceStatus
0096 E4                CLR     A
0097 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 825
0098 900000      R     MOV     DPTR,#USBUART_initVar
009B E4                CLR     A
009C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 826
009D 22                RET     
             ; FUNCTION USBUART_Stop (END)

             ; FUNCTION USBUART_CheckActivity (BEGIN)
                                           ; SOURCE LINE # 849
                                           ; SOURCE LINE # 850
                                           ; SOURCE LINE # 851
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 59  

0000 906009            MOV     DPTR,#06009H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#cr1Reg
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 854
000A 900000      R     MOV     DPTR,#cr1Reg
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 54FB              ANL     A,#0FBH
0012 FF                MOV     R7,A
0013 906009            MOV     DPTR,#06009H
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 857
0018 900000      R     MOV     DPTR,#cr1Reg
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 30E204            JNB     ACC.2,?C0017
0021 7F01              MOV     R7,#01H
0023 8002              SJMP    ?C0018
0025         ?C0017:
0025 7F00              MOV     R7,#00H
0027         ?C0018:
                                           ; SOURCE LINE # 858
0027         ?C0019:
0027 22                RET     
             ; FUNCTION USBUART_CheckActivity (END)

             ; FUNCTION USBUART_GetConfiguration (BEGIN)
                                           ; SOURCE LINE # 872
                                           ; SOURCE LINE # 873
                                           ; SOURCE LINE # 874
0000 900000      E     MOV     DPTR,#USBUART_configuration
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 875
0005         ?C0020:
0005 22                RET     
             ; FUNCTION USBUART_GetConfiguration (END)

             ; FUNCTION USBUART_IsConfigurationChanged (BEGIN)
                                           ; SOURCE LINE # 898
                                           ; SOURCE LINE # 899
                                           ; SOURCE LINE # 900
0000 900000      R     MOV     DPTR,#res
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 902
0005 900000      E     MOV     DPTR,#USBUART_configurationChanged
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600F              JZ      ?C0021
                                           ; SOURCE LINE # 903
                                           ; SOURCE LINE # 904
000D 900000      E     MOV     DPTR,#USBUART_configurationChanged
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 60  

0012 900000      R     MOV     DPTR,#res
0015 EF                MOV     A,R7
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 905
0017 900000      E     MOV     DPTR,#USBUART_configurationChanged
001A E4                CLR     A
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 906
001C         ?C0021:
                                           ; SOURCE LINE # 908
001C 900000      R     MOV     DPTR,#res
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
                                           ; SOURCE LINE # 909
0021         ?C0022:
0021 22                RET     
             ; FUNCTION USBUART_IsConfigurationChanged (END)

             ; FUNCTION _USBUART_GetInterfaceSetting (BEGIN)
                                           ; SOURCE LINE # 927
0000 900000      R     MOV     DPTR,#interfaceNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 929
                                           ; SOURCE LINE # 930
0005 900000      R     MOV     DPTR,#interfaceNumber
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 7400        E     MOV     A,#LOW USBUART_interfaceSetting
000C 2F                ADD     A,R7
000D F582              MOV     DPL,A
000F E4                CLR     A
0010 3400        E     ADDC    A,#HIGH USBUART_interfaceSetting
0012 F583              MOV     DPH,A
0014 E0                MOVX    A,@DPTR
0015 FF                MOV     R7,A
                                           ; SOURCE LINE # 931
0016         ?C0023:
0016 22                RET     
             ; FUNCTION _USBUART_GetInterfaceSetting (END)

             ; FUNCTION _USBUART_GetEPState (BEGIN)
                                           ; SOURCE LINE # 959
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 960
                                           ; SOURCE LINE # 961
0005 900000      R     MOV     DPTR,#epNumber
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 75F00B            MOV     B,#0BH
000E A4                MUL     AB
000F 2400        E     ADD     A,#LOW USBUART_EP+01H
0011 F582              MOV     DPL,A
0013 E4                CLR     A
0014 3400        E     ADDC    A,#HIGH USBUART_EP+01H
0016 F583              MOV     DPH,A
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
                                           ; SOURCE LINE # 962
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 61  

001A         ?C0024:
001A 22                RET     
             ; FUNCTION _USBUART_GetEPState (END)

             ; FUNCTION _USBUART_GetEPCount (BEGIN)
                                           ; SOURCE LINE # 982
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 983
                                           ; SOURCE LINE # 984
0005 900000      R     MOV     DPTR,#cntr
0008 E4                CLR     A
0009 F0                MOVX    @DPTR,A
000A A3                INC     DPTR
000B E4                CLR     A
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 986
000D 900000      R     MOV     DPTR,#epNumber
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 EF                MOV     A,R7
0013 D3                SETB    C
0014 9400              SUBB    A,#00H
0016 4066              JC      ?C0025
0018 900000      R     MOV     DPTR,#epNumber
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E C3                CLR     C
001F 9409              SUBB    A,#09H
0021 505B              JNC     ?C0025
                                           ; SOURCE LINE # 987
                                           ; SOURCE LINE # 989
0023 900000      R     MOV     DPTR,#epNumber
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 75F010            MOV     B,#010H
002B EF                MOV     A,R7
002C 905FFC            MOV     DPTR,#05FFCH
002F 120000      E     LCALL   ?C?OFFXADD
0032 E0                MOVX    A,@DPTR
0033 FF                MOV     R7,A
0034 7E00              MOV     R6,#00H
0036 7E00              MOV     R6,#00H
0038 EF                MOV     A,R7
0039 540F              ANL     A,#0FH
003B FF                MOV     R7,A
003C 900000      R     MOV     DPTR,#cntr
003F EE                MOV     A,R6
0040 F0                MOVX    @DPTR,A
0041 A3                INC     DPTR
0042 EF                MOV     A,R7
0043 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 990
0044 900000      R     MOV     DPTR,#epNumber
0047 E0                MOVX    A,@DPTR
0048 FF                MOV     R7,A
0049 75F010            MOV     B,#010H
004C EF                MOV     A,R7
004D 905FFD            MOV     DPTR,#05FFDH
0050 120000      E     LCALL   ?C?OFFXADD
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 62  

0053 E0                MOVX    A,@DPTR
0054 FF                MOV     R7,A
0055 EF                MOV     A,R7
0056 FD                MOV     R5,A
0057 7C00              MOV     R4,#00H
0059 900000      R     MOV     DPTR,#cntr
005C E0                MOVX    A,@DPTR
005D FE                MOV     R6,A
005E A3                INC     DPTR
005F E0                MOVX    A,@DPTR
0060 FF                MOV     R7,A
0061 EF                MOV     A,R7
0062 7F00              MOV     R7,#00H
0064 FE                MOV     R6,A
0065 EE                MOV     A,R6
0066 4C                ORL     A,R4
0067 FE                MOV     R6,A
0068 EF                MOV     A,R7
0069 4D                ORL     A,R5
006A FF                MOV     R7,A
006B 900000      R     MOV     DPTR,#cntr
006E EE                MOV     A,R6
006F F0                MOVX    @DPTR,A
0070 A3                INC     DPTR
0071 EF                MOV     A,R7
0072 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 991
0073 900000      R     MOV     DPTR,#cntr
0076 74FF              MOV     A,#0FFH
0078 75F0FE            MOV     B,#0FEH
007B 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 992
007E         ?C0025:
                                           ; SOURCE LINE # 994
007E 900000      R     MOV     DPTR,#cntr
0081 E0                MOVX    A,@DPTR
0082 FE                MOV     R6,A
0083 A3                INC     DPTR
0084 E0                MOVX    A,@DPTR
0085 FF                MOV     R7,A
                                           ; SOURCE LINE # 995
0086         ?C0026:
0086 22                RET     
             ; FUNCTION _USBUART_GetEPCount (END)

             ; FUNCTION _USBUART_LoadInEP (BEGIN)
                                           ; SOURCE LINE # 1342
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#pData
0008 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1344
                                           ; SOURCE LINE # 1345
000B 900000      R     MOV     DPTR,#epNumber
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 D3                SETB    C
0012 9400              SUBB    A,#00H
0014 5003              JNC     $ + 5H
0016 020000      R     LJMP    ?C0033
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 63  

0019 900000      R     MOV     DPTR,#epNumber
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E EF                MOV     A,R7
001F C3                CLR     C
0020 9409              SUBB    A,#09H
0022 4003              JC      $ + 5H
0024 020000      R     LJMP    ?C0033
                                           ; SOURCE LINE # 1346
                                           ; SOURCE LINE # 1349
0027 900000      R     MOV     DPTR,#epNumber
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D 75F00B            MOV     B,#0BH
0030 A4                MUL     AB
0031 2400        E     ADD     A,#LOW USBUART_EP+06H
0033 F582              MOV     DPL,A
0035 E4                CLR     A
0036 3400        E     ADDC    A,#HIGH USBUART_EP+06H
0038 F583              MOV     DPH,A
003A E0                MOVX    A,@DPTR
003B FE                MOV     R6,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FF                MOV     R7,A
003F C3                CLR     C
0040 E4                CLR     A
0041 9F                SUBB    A,R7
0042 FF                MOV     R7,A
0043 7402              MOV     A,#02H
0045 9E                SUBB    A,R6
0046 FE                MOV     R6,A
0047 900000      R     MOV     DPTR,#length
004A E0                MOVX    A,@DPTR
004B FC                MOV     R4,A
004C A3                INC     DPTR
004D E0                MOVX    A,@DPTR
004E FD                MOV     R5,A
004F D3                SETB    C
0050 ED                MOV     A,R5
0051 9F                SUBB    A,R7
0052 EC                MOV     A,R4
0053 9E                SUBB    A,R6
0054 4028              JC      ?C0028
                                           ; SOURCE LINE # 1350
                                           ; SOURCE LINE # 1351
0056 900000      R     MOV     DPTR,#epNumber
0059 E0                MOVX    A,@DPTR
005A FF                MOV     R7,A
005B EF                MOV     A,R7
005C 75F00B            MOV     B,#0BH
005F A4                MUL     AB
0060 2400        E     ADD     A,#LOW USBUART_EP+06H
0062 F582              MOV     DPL,A
0064 E4                CLR     A
0065 3400        E     ADDC    A,#HIGH USBUART_EP+06H
0067 F583              MOV     DPH,A
0069 E0                MOVX    A,@DPTR
006A FE                MOV     R6,A
006B A3                INC     DPTR
006C E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 64  

006D FF                MOV     R7,A
006E C3                CLR     C
006F E4                CLR     A
0070 9F                SUBB    A,R7
0071 FF                MOV     R7,A
0072 7402              MOV     A,#02H
0074 9E                SUBB    A,R6
0075 FE                MOV     R6,A
0076 900000      R     MOV     DPTR,#length
0079 EE                MOV     A,R6
007A F0                MOVX    @DPTR,A
007B A3                INC     DPTR
007C EF                MOV     A,R7
007D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1352
007E         ?C0028:
                                           ; SOURCE LINE # 1356
007E 900000      R     MOV     DPTR,#length
0081 E0                MOVX    A,@DPTR
0082 FE                MOV     R6,A
0083 A3                INC     DPTR
0084 E0                MOVX    A,@DPTR
0085 FF                MOV     R7,A
0086 EE                MOV     A,R6
0087 FF                MOV     R7,A
0088 7E00              MOV     R6,#00H
008A 900000      R     MOV     DPTR,#epNumber
008D E0                MOVX    A,@DPTR
008E FE                MOV     R6,A
008F EE                MOV     A,R6
0090 75F00B            MOV     B,#0BH
0093 A4                MUL     AB
0094 2400        E     ADD     A,#LOW USBUART_EP+03H
0096 F582              MOV     DPL,A
0098 E4                CLR     A
0099 3400        E     ADDC    A,#HIGH USBUART_EP+03H
009B F583              MOV     DPH,A
009D E0                MOVX    A,@DPTR
009E FE                MOV     R6,A
009F EF                MOV     A,R7
00A0 4E                ORL     A,R6
00A1 FF                MOV     R7,A
00A2 900000      R     MOV     DPTR,#epNumber
00A5 E0                MOVX    A,@DPTR
00A6 FE                MOV     R6,A
00A7 75F010            MOV     B,#010H
00AA EE                MOV     A,R6
00AB 905FFC            MOV     DPTR,#05FFCH
00AE 120000      E     LCALL   ?C?OFFXADD
00B1 EF                MOV     A,R7
00B2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1357
00B3 900000      R     MOV     DPTR,#length
00B6 E0                MOVX    A,@DPTR
00B7 FE                MOV     R6,A
00B8 A3                INC     DPTR
00B9 E0                MOVX    A,@DPTR
00BA FF                MOV     R7,A
00BB EF                MOV     A,R7
00BC 54FF              ANL     A,#0FFH
00BE FF                MOV     R7,A
00BF 900000      R     MOV     DPTR,#epNumber
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 65  

00C2 E0                MOVX    A,@DPTR
00C3 FE                MOV     R6,A
00C4 75F010            MOV     B,#010H
00C7 EE                MOV     A,R6
00C8 905FFD            MOV     DPTR,#05FFDH
00CB 120000      E     LCALL   ?C?OFFXADD
00CE EF                MOV     A,R7
00CF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1360
00D0 7B00              MOV     R3,#00H
00D2 7A00              MOV     R2,#00H
00D4 7900              MOV     R1,#00H
00D6 C003              PUSH    AR3
00D8 C002              PUSH    AR2
00DA C001              PUSH    AR1
00DC 900000      R     MOV     DPTR,#pData
00DF 120000      E     LCALL   ?C?PLDXDATA
00E2 D082              POP     DPL
00E4 D083              POP     DPH
00E6 D0E0              POP     ACC
00E8 6B                XRL     A,R3
00E9 7008              JNZ     ?C0057
00EB E9                MOV     A,R1
00EC 6582              XRL     A,DPL
00EE 7003              JNZ     ?C0057
00F0 EA                MOV     A,R2
00F1 6583              XRL     A,DPH
00F3         ?C0057:
00F3 6054              JZ      ?C0029
                                           ; SOURCE LINE # 1361
                                           ; SOURCE LINE # 1364
00F5 900000      R     MOV     DPTR,#i
00F8 E4                CLR     A
00F9 F0                MOVX    @DPTR,A
00FA A3                INC     DPTR
00FB E4                CLR     A
00FC F0                MOVX    @DPTR,A
00FD         ?C0030:
00FD 900000      R     MOV     DPTR,#length
0100 E0                MOVX    A,@DPTR
0101 FE                MOV     R6,A
0102 A3                INC     DPTR
0103 E0                MOVX    A,@DPTR
0104 FF                MOV     R7,A
0105 900000      R     MOV     DPTR,#i
0108 E0                MOVX    A,@DPTR
0109 FC                MOV     R4,A
010A A3                INC     DPTR
010B E0                MOVX    A,@DPTR
010C FD                MOV     R5,A
010D C3                CLR     C
010E ED                MOV     A,R5
010F 9F                SUBB    A,R7
0110 EC                MOV     A,R4
0111 9E                SUBB    A,R6
0112 5035              JNC     ?C0029
                                           ; SOURCE LINE # 1365
                                           ; SOURCE LINE # 1366
0114 900000      R     MOV     DPTR,#pData
0117 120000      E     LCALL   ?C?PLDXDATA
011A 900000      R     MOV     DPTR,#i
011D E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 66  

011E FE                MOV     R6,A
011F A3                INC     DPTR
0120 E0                MOVX    A,@DPTR
0121 FF                MOV     R7,A
0122 E9                MOV     A,R1
0123 2F                ADD     A,R7
0124 F9                MOV     R1,A
0125 EA                MOV     A,R2
0126 3E                ADDC    A,R6
0127 FA                MOV     R2,A
0128 120000      E     LCALL   ?C?CLDPTR
012B FF                MOV     R7,A
012C 900000      R     MOV     DPTR,#epNumber
012F E0                MOVX    A,@DPTR
0130 FE                MOV     R6,A
0131 75F010            MOV     B,#010H
0134 EE                MOV     A,R6
0135 906078            MOV     DPTR,#06078H
0138 120000      E     LCALL   ?C?OFFXADD
013B EF                MOV     A,R7
013C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1367
013D 900000      R     MOV     DPTR,#i
0140 E4                CLR     A
0141 75F001            MOV     B,#01H
0144 120000      E     LCALL   ?C?IILDX
0147 80B4              SJMP    ?C0030
                                           ; SOURCE LINE # 1368
0149         ?C0029:
                                           ; SOURCE LINE # 1371
0149 900000      R     MOV     DPTR,#epNumber
014C E0                MOVX    A,@DPTR
014D FF                MOV     R7,A
014E EF                MOV     A,R7
014F 75F00B            MOV     B,#0BH
0152 A4                MUL     AB
0153 2400        E     ADD     A,#LOW USBUART_EP+01H
0155 F582              MOV     DPL,A
0157 E4                CLR     A
0158 3400        E     ADDC    A,#HIGH USBUART_EP+01H
015A F583              MOV     DPH,A
015C E4                CLR     A
015D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1374
015E 900000      R     MOV     DPTR,#epNumber
0161 E0                MOVX    A,@DPTR
0162 FF                MOV     R7,A
0163 EF                MOV     A,R7
0164 75F00B            MOV     B,#0BH
0167 A4                MUL     AB
0168 2400        E     ADD     A,#LOW USBUART_EP+05H
016A F582              MOV     DPL,A
016C E4                CLR     A
016D 3400        E     ADDC    A,#HIGH USBUART_EP+05H
016F F583              MOV     DPH,A
0171 E0                MOVX    A,@DPTR
0172 FF                MOV     R7,A
0173 900000      R     MOV     DPTR,#epNumber
0176 E0                MOVX    A,@DPTR
0177 FE                MOV     R6,A
0178 75F010            MOV     B,#010H
017B EE                MOV     A,R6
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 67  

017C 905FFE            MOV     DPTR,#05FFEH
017F 120000      E     LCALL   ?C?OFFXADD
0182 EF                MOV     A,R7
0183 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1603
                                           ; SOURCE LINE # 1604
0184         ?C0033:
0184 22                RET     
             ; FUNCTION _USBUART_LoadInEP (END)

             ; FUNCTION _USBUART_ReadOutEP (BEGIN)
                                           ; SOURCE LINE # 1653
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#pData
0008 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1655
                                           ; SOURCE LINE # 1656
000B 7B00              MOV     R3,#00H
000D 7A00              MOV     R2,#00H
000F 7900              MOV     R1,#00H
0011 C003              PUSH    AR3
0013 C002              PUSH    AR2
0015 C001              PUSH    AR1
0017 900000      R     MOV     DPTR,#pData
001A 120000      E     LCALL   ?C?PLDXDATA
001D D082              POP     DPL
001F D083              POP     DPH
0021 D0E0              POP     ACC
0023 6B                XRL     A,R3
0024 7008              JNZ     ?C0058
0026 E9                MOV     A,R1
0027 6582              XRL     A,DPL
0029 7003              JNZ     ?C0058
002B EA                MOV     A,R2
002C 6583              XRL     A,DPH
002E         ?C0058:
002E 7003              JNZ     $ + 5H
0030 020000      R     LJMP    ?C0034
0033 900000      R     MOV     DPTR,#epNumber
0036 E0                MOVX    A,@DPTR
0037 FF                MOV     R7,A
0038 EF                MOV     A,R7
0039 D3                SETB    C
003A 9400              SUBB    A,#00H
003C 5003              JNC     $ + 5H
003E 020000      R     LJMP    ?C0034
0041 900000      R     MOV     DPTR,#epNumber
0044 E0                MOVX    A,@DPTR
0045 FF                MOV     R7,A
0046 EF                MOV     A,R7
0047 C3                CLR     C
0048 9409              SUBB    A,#09H
004A 4003              JC      $ + 5H
004C 020000      R     LJMP    ?C0034
                                           ; SOURCE LINE # 1657
                                           ; SOURCE LINE # 1660
004F 900000      R     MOV     DPTR,#epNumber
0052 E0                MOVX    A,@DPTR
0053 FF                MOV     R7,A
0054 120000      R     LCALL   _USBUART_GetEPCount
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 68  

0057 900000      R     MOV     DPTR,#length
005A E0                MOVX    A,@DPTR
005B FC                MOV     R4,A
005C A3                INC     DPTR
005D E0                MOVX    A,@DPTR
005E FD                MOV     R5,A
005F D3                SETB    C
0060 ED                MOV     A,R5
0061 9F                SUBB    A,R7
0062 EC                MOV     A,R4
0063 9E                SUBB    A,R6
0064 400A              JC      ?C0035
0066 900000      R     MOV     DPTR,#epNumber
0069 E0                MOVX    A,@DPTR
006A FF                MOV     R7,A
006B 120000      R     LCALL   _USBUART_GetEPCount
006E 8008              SJMP    ?C0036
0070         ?C0035:
0070 900000      R     MOV     DPTR,#length
0073 E0                MOVX    A,@DPTR
0074 FE                MOV     R6,A
0075 A3                INC     DPTR
0076 E0                MOVX    A,@DPTR
0077 FF                MOV     R7,A
0078         ?C0036:
0078 900000      R     MOV     DPTR,#length
007B EE                MOV     A,R6
007C F0                MOVX    @DPTR,A
007D A3                INC     DPTR
007E EF                MOV     A,R7
007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1664
                                           ; SOURCE LINE # 1667
0080 900000      R     MOV     DPTR,#i
0083 E4                CLR     A
0084 F0                MOVX    @DPTR,A
0085 A3                INC     DPTR
0086 E4                CLR     A
0087 F0                MOVX    @DPTR,A
0088         ?C0037:
0088 900000      R     MOV     DPTR,#length
008B E0                MOVX    A,@DPTR
008C FE                MOV     R6,A
008D A3                INC     DPTR
008E E0                MOVX    A,@DPTR
008F FF                MOV     R7,A
0090 900000      R     MOV     DPTR,#i
0093 E0                MOVX    A,@DPTR
0094 FC                MOV     R4,A
0095 A3                INC     DPTR
0096 E0                MOVX    A,@DPTR
0097 FD                MOV     R5,A
0098 C3                CLR     C
0099 ED                MOV     A,R5
009A 9F                SUBB    A,R7
009B EC                MOV     A,R4
009C 9E                SUBB    A,R6
009D 5035              JNC     ?C0038
                                           ; SOURCE LINE # 1668
                                           ; SOURCE LINE # 1669
009F 900000      R     MOV     DPTR,#epNumber
00A2 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 69  

00A3 FF                MOV     R7,A
00A4 75F010            MOV     B,#010H
00A7 EF                MOV     A,R7
00A8 906078            MOV     DPTR,#06078H
00AB 120000      E     LCALL   ?C?OFFXADD
00AE E0                MOVX    A,@DPTR
00AF FF                MOV     R7,A
00B0 900000      R     MOV     DPTR,#pData
00B3 120000      E     LCALL   ?C?PLDXDATA
00B6 900000      R     MOV     DPTR,#i
00B9 E0                MOVX    A,@DPTR
00BA FC                MOV     R4,A
00BB A3                INC     DPTR
00BC E0                MOVX    A,@DPTR
00BD FD                MOV     R5,A
00BE E9                MOV     A,R1
00BF 2D                ADD     A,R5
00C0 F9                MOV     R1,A
00C1 EA                MOV     A,R2
00C2 3C                ADDC    A,R4
00C3 FA                MOV     R2,A
00C4 EF                MOV     A,R7
00C5 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 1670
00C8 900000      R     MOV     DPTR,#i
00CB E4                CLR     A
00CC 75F001            MOV     B,#01H
00CF 120000      E     LCALL   ?C?IILDX
00D2 80B4              SJMP    ?C0037
00D4         ?C0038:
                                           ; SOURCE LINE # 1671
                                           ; SOURCE LINE # 1674
00D4 900000      R     MOV     DPTR,#epNumber
00D7 E0                MOVX    A,@DPTR
00D8 FF                MOV     R7,A
00D9 120000      R     LCALL   _USBUART_EnableOutEP
                                           ; SOURCE LINE # 1817
00DC 8008              SJMP    ?C0040
00DE         ?C0034:
                                           ; SOURCE LINE # 1819
                                           ; SOURCE LINE # 1820
00DE 900000      R     MOV     DPTR,#length
00E1 E4                CLR     A
00E2 F0                MOVX    @DPTR,A
00E3 A3                INC     DPTR
00E4 E4                CLR     A
00E5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1821
00E6         ?C0040:
                                           ; SOURCE LINE # 1823
00E6 900000      R     MOV     DPTR,#length
00E9 E0                MOVX    A,@DPTR
00EA FE                MOV     R6,A
00EB A3                INC     DPTR
00EC E0                MOVX    A,@DPTR
00ED FF                MOV     R7,A
                                           ; SOURCE LINE # 1824
00EE         ?C0041:
00EE 22                RET     
             ; FUNCTION _USBUART_ReadOutEP (END)

             ; FUNCTION _USBUART_EnableOutEP (BEGIN)
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 70  

                                           ; SOURCE LINE # 2276
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2277
                                           ; SOURCE LINE # 2278
0005 900000      R     MOV     DPTR,#epNumber
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B D3                SETB    C
000C 9400              SUBB    A,#00H
000E 4046              JC      ?C0043
0010 900000      R     MOV     DPTR,#epNumber
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 C3                CLR     C
0017 9409              SUBB    A,#09H
0019 503B              JNC     ?C0043
                                           ; SOURCE LINE # 2279
                                           ; SOURCE LINE # 2280
001B 900000      R     MOV     DPTR,#epNumber
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 EF                MOV     A,R7
0021 75F00B            MOV     B,#0BH
0024 A4                MUL     AB
0025 2400        E     ADD     A,#LOW USBUART_EP+01H
0027 F582              MOV     DPL,A
0029 E4                CLR     A
002A 3400        E     ADDC    A,#HIGH USBUART_EP+01H
002C F583              MOV     DPH,A
002E E4                CLR     A
002F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2283
0030 900000      R     MOV     DPTR,#epNumber
0033 E0                MOVX    A,@DPTR
0034 FF                MOV     R7,A
0035 EF                MOV     A,R7
0036 75F00B            MOV     B,#0BH
0039 A4                MUL     AB
003A 2400        E     ADD     A,#LOW USBUART_EP+05H
003C F582              MOV     DPL,A
003E E4                CLR     A
003F 3400        E     ADDC    A,#HIGH USBUART_EP+05H
0041 F583              MOV     DPH,A
0043 E0                MOVX    A,@DPTR
0044 FF                MOV     R7,A
0045 900000      R     MOV     DPTR,#epNumber
0048 E0                MOVX    A,@DPTR
0049 FE                MOV     R6,A
004A 75F010            MOV     B,#010H
004D EE                MOV     A,R6
004E 905FFE            MOV     DPTR,#05FFEH
0051 120000      E     LCALL   ?C?OFFXADD
0054 EF                MOV     A,R7
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2285
                                           ; SOURCE LINE # 2286
0056         ?C0043:
0056 22                RET     
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 71  

             ; FUNCTION _USBUART_EnableOutEP (END)

             ; FUNCTION _USBUART_DisableOutEP (BEGIN)
                                           ; SOURCE LINE # 2300
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2301
                                           ; SOURCE LINE # 2302
0005 900000      R     MOV     DPTR,#epNumber
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B D3                SETB    C
000C 9400              SUBB    A,#00H
000E 401D              JC      ?C0045
0010 900000      R     MOV     DPTR,#epNumber
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 C3                CLR     C
0017 9409              SUBB    A,#09H
0019 5012              JNC     ?C0045
                                           ; SOURCE LINE # 2303
                                           ; SOURCE LINE # 2305
001B 900000      R     MOV     DPTR,#epNumber
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 75F010            MOV     B,#010H
0023 EF                MOV     A,R7
0024 905FFE            MOV     DPTR,#05FFEH
0027 120000      E     LCALL   ?C?OFFXADD
002A 7408              MOV     A,#08H
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2306
                                           ; SOURCE LINE # 2307
002D         ?C0045:
002D 22                RET     
             ; FUNCTION _USBUART_DisableOutEP (END)

             ; FUNCTION _USBUART_Force (BEGIN)
                                           ; SOURCE LINE # 2330
0000 900000      R     MOV     DPTR,#bState
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2331
                                           ; SOURCE LINE # 2335
0005 900000      R     MOV     DPTR,#bState
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906010            MOV     DPTR,#06010H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2336
000F 22                RET     
             ; FUNCTION _USBUART_Force (END)

             ; FUNCTION _USBUART_GetEPAckState (BEGIN)
                                           ; SOURCE LINE # 2355
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 72  

                                           ; SOURCE LINE # 2356
                                           ; SOURCE LINE # 2357
0005 900000      R     MOV     DPTR,#cr
0008 E4                CLR     A
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2359
000A 900000      R     MOV     DPTR,#epNumber
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 D3                SETB    C
0011 9400              SUBB    A,#00H
0013 4025              JC      ?C0047
0015 900000      R     MOV     DPTR,#epNumber
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
001A EF                MOV     A,R7
001B C3                CLR     C
001C 9409              SUBB    A,#09H
001E 501A              JNC     ?C0047
                                           ; SOURCE LINE # 2360
                                           ; SOURCE LINE # 2361
0020 900000      R     MOV     DPTR,#epNumber
0023 E0                MOVX    A,@DPTR
0024 FF                MOV     R7,A
0025 75F010            MOV     B,#010H
0028 EF                MOV     A,R7
0029 905FFE            MOV     DPTR,#05FFEH
002C 120000      E     LCALL   ?C?OFFXADD
002F E0                MOVX    A,@DPTR
0030 FF                MOV     R7,A
0031 EF                MOV     A,R7
0032 5410              ANL     A,#010H
0034 FF                MOV     R7,A
0035 900000      R     MOV     DPTR,#cr
0038 EF                MOV     A,R7
0039 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2362
003A         ?C0047:
                                           ; SOURCE LINE # 2364
003A 900000      R     MOV     DPTR,#cr
003D E0                MOVX    A,@DPTR
003E FF                MOV     R7,A
                                           ; SOURCE LINE # 2365
003F         ?C0048:
003F 22                RET     
             ; FUNCTION _USBUART_GetEPAckState (END)

             ; FUNCTION _USBUART_SetPowerStatus (BEGIN)
                                           ; SOURCE LINE # 2396
0000 900000      R     MOV     DPTR,#powerStatus
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2397
                                           ; SOURCE LINE # 2398
0005 900000      R     MOV     DPTR,#powerStatus
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600F              JZ      ?C0049
                                           ; SOURCE LINE # 2399
                                           ; SOURCE LINE # 2400
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 73  

000D 900000      E     MOV     DPTR,#USBUART_deviceStatus
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 EF                MOV     A,R7
0013 4401              ORL     A,#01H
0015 FF                MOV     R7,A
0016 900000      E     MOV     DPTR,#USBUART_deviceStatus
0019 EF                MOV     A,R7
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2401
001B 22                RET     
001C         ?C0049:
                                           ; SOURCE LINE # 2403
                                           ; SOURCE LINE # 2404
001C 900000      E     MOV     DPTR,#USBUART_deviceStatus
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 54FE              ANL     A,#0FEH
0024 FF                MOV     R7,A
0025 900000      E     MOV     DPTR,#USBUART_deviceStatus
0028 EF                MOV     A,R7
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2405
                                           ; SOURCE LINE # 2406
002A         ?C0051:
002A 22                RET     
             ; FUNCTION _USBUART_SetPowerStatus (END)

             ; FUNCTION USBUART_RWUEnabled (BEGIN)
                                           ; SOURCE LINE # 2453
                                           ; SOURCE LINE # 2454
                                           ; SOURCE LINE # 2455
0000 900000      R     MOV     DPTR,#result
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2457
0005 900000      E     MOV     DPTR,#USBUART_deviceStatus
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 5402              ANL     A,#02H
000D FF                MOV     R7,A
000E 7E00              MOV     R6,#00H
0010 EF                MOV     A,R7
0011 4E                ORL     A,R6
0012 6006              JZ      ?C0052
                                           ; SOURCE LINE # 2458
                                           ; SOURCE LINE # 2459
0014 900000      R     MOV     DPTR,#result
0017 7401              MOV     A,#01H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2460
001A         ?C0052:
                                           ; SOURCE LINE # 2462
001A 900000      R     MOV     DPTR,#result
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
                                           ; SOURCE LINE # 2463
001F         ?C0053:
001F 22                RET     
             ; FUNCTION USBUART_RWUEnabled (END)
C51 COMPILER V9.51   USBUART                                                               04/01/2024 15:28:44 PAGE 74  


             ; FUNCTION USBUART_GetDeviceAddress (BEGIN)
                                           ; SOURCE LINE # 2477
                                           ; SOURCE LINE # 2478
                                           ; SOURCE LINE # 2479
0000 906008            MOV     DPTR,#06008H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 547F              ANL     A,#07FH
0008 FF                MOV     R7,A
                                           ; SOURCE LINE # 2480
0009         ?C0054:
0009 22                RET     
             ; FUNCTION USBUART_GetDeviceAddress (END)

             ; FUNCTION USBUART_EnableSofInt (BEGIN)
                                           ; SOURCE LINE # 2491
                                           ; SOURCE LINE # 2492
                                           ; SOURCE LINE # 2499
0000 9044C2            MOV     DPTR,#044C2H
0003 7420              MOV     A,#020H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2502
0006 22                RET     
             ; FUNCTION USBUART_EnableSofInt (END)

             ; FUNCTION USBUART_DisableSofInt (BEGIN)
                                           ; SOURCE LINE # 2513
                                           ; SOURCE LINE # 2514
                                           ; SOURCE LINE # 2521
0000 9044CA            MOV     DPTR,#044CAH
0003 7420              MOV     A,#020H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2524
0006 22                RET     
             ; FUNCTION USBUART_DisableSofInt (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2002    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      38
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
